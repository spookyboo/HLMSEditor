/****************************************************************************
**
** Copyright (C) 2016
**
** This file is generated by the Magus toolkit
**
** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
** "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
** LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
** A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
** OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
** LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
** DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
** OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
**
****************************************************************************/

// Include
#include <QMessageBox>
#include "constants.h"
#include "node_port.h"
#include "hlms_pbs_builder.h"
#include "OgreItem.h"
#include "OgreResourceGroupManager.h"
#include "OgreHlmsManager.h"

//****************************************************************************/
HlmsPbsBuilder::HlmsPbsBuilder(Magus::QtNodeEditor* nodeEditor) :
    HlmsBuilder(),
    mNodeEditor(nodeEditor)
{
    mTempOgreString = "";
}

//****************************************************************************/
HlmsPbsBuilder::~HlmsPbsBuilder(void)
{
}

//****************************************************************************/
Ogre::HlmsPbsDatablock* HlmsPbsBuilder::createPbsDatablock (Magus::OgreManager* ogreManager,
                                                            HlmsNodePbsDatablock* pbsnode)
{
    // Get the ogre manager and root
    Ogre::Root* root = ogreManager->getOgreRoot();

    // Create a Pbs datablock
    Ogre::HlmsManager* hlmsManager = root->getHlmsManager();
    Ogre::HlmsTextureManager* hlmsTextureManager = hlmsManager->getTextureManager();
    Ogre::HlmsPbs* hlmsPbs = static_cast<Ogre::HlmsPbs*>( hlmsManager->getHlms(Ogre::HLMS_PBS) );

    // Determine whether a macro node is attached (and enabled)
    Ogre::HlmsMacroblock macroblock;
    Magus::QtNode* mnode = pbsnode->getNodeConnectedToPort(PORT_MACROBLOCK);
    if (mnode)
    {
        // There is a macroblock; enrich it with the node data if enabled
        HlmsNodeMacroblock* macronode = static_cast<HlmsNodeMacroblock*>(mnode);
        if (macronode->getMacroblockEnabled())
            enrichMacroblock(macronode, &macroblock);
    }

    // Determine whether a blend node is attached (and enabled)
    Ogre::HlmsBlendblock blendblock;
    Magus::QtNode* bnode = pbsnode->getNodeConnectedToPort(PORT_BLENDBLOCK);
    if (bnode)
    {
        // There is a blendblock; enrich it with the node data if enabled
        HlmsNodeBlendblock* blendnode = static_cast<HlmsNodeBlendblock*>(bnode);
        if (blendnode->getBlendblockEnabled())
            enrichBlendblock(blendnode, &blendblock);
    }

    // First destroy any existing datablock with that name
    Ogre::String datablockName = pbsnode->getName().toStdString(); // TODO Ogre::String -> Ogre::IdString
    Ogre::HlmsDatablock* latestDatablock = hlmsPbs->getDatablock(datablockName);
    if (latestDatablock && latestDatablock != hlmsPbs->getDefaultDatablock())
        hlmsPbs->destroyDatablock(latestDatablock->getName());

    // Create a new datablock and use the (new) name defined in the node
    Ogre::HlmsPbsDatablock* datablock = static_cast<Ogre::HlmsPbsDatablock*>(
                hlmsPbs->createDatablock( datablockName,
                                          datablockName,
                                          macroblock,
                                          blendblock,
                                          Ogre::HlmsParamVec()));

    // Set the datablock properties
    enrichPbsDatablock(datablock, pbsnode);

    // Run through all nodes connected to the pbsnode
    QVector<Magus::QtNode*> nodes = pbsnode->getNodes();
    Ogre::PbsTextureTypes textureType;
    Ogre::HlmsTextureManager::TextureMapType textureMapType;
    Ogre::String texName;
    Ogre::String dataFolder;
    foreach(Magus::QtNode* node, nodes)
    {
        if (node)
        {
            if (node->getType() == NODE_TYPE_SAMPLERBLOCK)
            {
                try
                {
                    // First check whether the texture/samperblock is enabled and must part of the datablock
                    HlmsNodeSamplerblock* samplernode = static_cast<HlmsNodeSamplerblock*>(node);
                    if (samplernode->getSamplerblockEnabled())
                    {
                        // Get the texture type from the sampler node and add a resourcelocation if needed
                        texName = samplernode->getBaseNameTexture().toStdString();
                        if (!texName.empty())
                        {
                            // The samplerblock has a name, so it is associcated with a real texture
                            textureType = getPbsTextureTypeFromSamplerNode(samplernode);
                            textureMapType = getTextureMapTypeFromSamplerNode(samplernode);

                            // Add resource location if needed
                            dataFolder = samplernode->getPathTexture().toStdString();
                            if (!isResourceLocationExisting(dataFolder))
                            {
                                root->addResourceLocation(dataFolder, "FileSystem", Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME);
                                saveAllResourcesLocations();
                            }

                            // Get the texture from the samplernode
                            Ogre::HlmsTextureManager::TextureLocation texLocation = hlmsTextureManager->
                                    createOrRetrieveTexture(texName, textureMapType);

                            // Create a samplerblock and add it to the datablock
                            Ogre::HlmsSamplerblock samplerblock;
                            enrichSamplerblock(datablock, &samplerblock, samplernode);
                            datablock->setTexture(textureType, texLocation.xIdx, texLocation.texture);
                            datablock->setSamplerblock(textureType, samplerblock);
                        }
                    }
                }
                catch (Ogre::Exception e)
                {
                    QMessageBox::information(0, QString("Error"), QString("Cannot create textures. Check Ogre.log"));
                }
            }
        }
    }

    return datablock;
}

//****************************************************************************/
HlmsNodePbsDatablock* HlmsPbsBuilder::createPbsNodeStructure(Magus::OgreManager* ogreManager,
                                                             const HlmsUtilsManager::DatablockStruct& datablockStruct)

{
    // Get the datablock
    HlmsNodePbsDatablock* pbsnode;
    Ogre::Root* root = ogreManager->getOgreRoot();
    Ogre::HlmsManager* hlmsManager = root->getHlmsManager();
    Ogre::HlmsPbs* hlmsPbs = static_cast<Ogre::HlmsPbs*>( hlmsManager->getHlms(Ogre::HLMS_PBS) );
    Ogre::HlmsPbsDatablock* datablock = static_cast<Ogre::HlmsPbsDatablock*>(hlmsPbs->getDatablock(datablockStruct.datablockId));
    if (datablock)
    {
        mNodeEditor->clear();

        // Create the pbs node
        pbsnode = createPbsNode();
        enrichPbsNode(pbsnode, datablock);

        // Get all textures from the pbs
        // Note, that each texture becomes one samplernode, while a datablock may contain multiple textures, but for example only one samplerblock
        HlmsNodeSamplerblock* samplernode;
        samplernode = createSamplerNode(datablock, pbsnode, Ogre::PBSM_DIFFUSE);
        enrichSamplerNode(samplernode, datablock, datablockStruct, Ogre::PBSM_DIFFUSE);

        samplernode = createSamplerNode(datablock, pbsnode, Ogre::PBSM_NORMAL);
        enrichSamplerNode(samplernode, datablock, datablockStruct, Ogre::PBSM_NORMAL);

        samplernode = createSamplerNode(datablock, pbsnode, Ogre::PBSM_SPECULAR);
        enrichSamplerNode(samplernode, datablock, datablockStruct, Ogre::PBSM_SPECULAR);

        // PBSM_METALLIC is same as PBSM_SPECULAR, so do not duplicate it
        //samplernode = createSamplerNode(datablock, pbsnode, Ogre::PBSM_METALLIC);
        //enrichSamplerNode(samplernode, datablock, Ogre::PBSM_METALLIC);

        samplernode = createSamplerNode(datablock, pbsnode, Ogre::PBSM_ROUGHNESS);
        enrichSamplerNode(samplernode, datablock, datablockStruct, Ogre::PBSM_ROUGHNESS);

        samplernode = createSamplerNode(datablock, pbsnode, Ogre::PBSM_DETAIL_WEIGHT);
        enrichSamplerNode(samplernode, datablock, datablockStruct, Ogre::PBSM_DETAIL_WEIGHT);

        samplernode = createSamplerNode(datablock, pbsnode, Ogre::PBSM_DETAIL0);
        enrichSamplerNode(samplernode, datablock, datablockStruct, Ogre::PBSM_DETAIL0);

        samplernode = createSamplerNode(datablock, pbsnode, Ogre::PBSM_DETAIL1);
        enrichSamplerNode(samplernode, datablock, datablockStruct, Ogre::PBSM_DETAIL1);

        samplernode = createSamplerNode(datablock, pbsnode, Ogre::PBSM_DETAIL2);
        enrichSamplerNode(samplernode, datablock, datablockStruct, Ogre::PBSM_DETAIL2);

        samplernode = createSamplerNode(datablock, pbsnode, Ogre::PBSM_DETAIL3);
        enrichSamplerNode(samplernode, datablock, datablockStruct, Ogre::PBSM_DETAIL3);

        samplernode = createSamplerNode(datablock, pbsnode, Ogre::PBSM_DETAIL0_NM);
        enrichSamplerNode(samplernode, datablock, datablockStruct, Ogre::PBSM_DETAIL0_NM);

        samplernode = createSamplerNode(datablock, pbsnode, Ogre::PBSM_DETAIL1_NM);
        enrichSamplerNode(samplernode, datablock, datablockStruct, Ogre::PBSM_DETAIL1_NM);

        samplernode = createSamplerNode(datablock, pbsnode, Ogre::PBSM_DETAIL2_NM);
        enrichSamplerNode(samplernode, datablock, datablockStruct, Ogre::PBSM_DETAIL2_NM);

        samplernode = createSamplerNode(datablock, pbsnode, Ogre::PBSM_DETAIL3_NM);
        enrichSamplerNode(samplernode, datablock, datablockStruct, Ogre::PBSM_DETAIL3_NM);

        samplernode = createSamplerNode(datablock, pbsnode, Ogre::PBSM_REFLECTION);
        enrichSamplerNode(samplernode, datablock, datablockStruct, Ogre::PBSM_REFLECTION);

        // Create and fill properties of the macronode with the values of the macroblock and connect the node to the pbs node
        const Ogre::HlmsMacroblock* macroblock = datablock->getMacroblock();
        if (!(!macroblock->mScissorTestEnabled &&
              macroblock->mDepthCheck &&
              macroblock->mDepthWrite &&
              macroblock->mDepthFunc == Ogre::CMPF_LESS_EQUAL &&
              macroblock->mDepthBiasConstant == 0.0f &&
              macroblock->mDepthBiasSlopeScale == 0.0f &&
              macroblock->mCullMode == Ogre::CULL_CLOCKWISE &&
              macroblock->mPolygonMode == Ogre::PM_SOLID))
        {
            // It is not a default macroblock, so create a new macro node and and set it in the pbs
            HlmsNodeMacroblock* macronode = createMacroNode(mNodeEditor);
            macronode->setMacroblockEnabled(true);
            macronode->setScissorTestEnabled(macroblock->mScissorTestEnabled);
            macronode->setDepthCheck(macroblock->mDepthCheck);
            macronode->setDepthWrite(macroblock->mDepthWrite);
            macronode->setDepthFunc(getIndexFromCompareFunction(macroblock->mDepthFunc));
            macronode->setDepthBiasConstant(macroblock->mDepthBiasConstant);
            macronode->setDepthBiasSlopeScale(macroblock->mDepthBiasSlopeScale);

            switch (macroblock->mCullMode)
            {
                case Ogre::CULL_NONE:
                    macronode->setCullMode(0);
                break;
                case Ogre::CULL_CLOCKWISE:
                    macronode->setCullMode(1);
                break;
                case Ogre::CULL_ANTICLOCKWISE:
                    macronode->setCullMode(2);
                break;
            }

            switch (macroblock->mPolygonMode)
            {
                case Ogre::PM_POINTS:
                    macronode->setPolygonMode(0);
                break;
                case Ogre::PM_WIREFRAME:
                    macronode->setPolygonMode(1);
                break;
                case Ogre::PM_SOLID:
                    macronode->setPolygonMode(2);
                break;
            }
            connectNodes(pbsnode, macronode); // Connect both nodes
        }

        // Create and fill properties of the blendnode with the values of the blendblock and connect the node to the pbs node
        const Ogre::HlmsBlendblock* blendblock = datablock->getBlendblock();
        if (!(!blendblock->mAlphaToCoverageEnabled &&
              blendblock->mBlendChannelMask == Ogre::HlmsBlendblock::BlendChannelAll &&
              !blendblock->mIsTransparent &&
              !blendblock->mSeparateBlend &&
              blendblock->mSourceBlendFactor == Ogre::SBF_ONE &&
              blendblock->mDestBlendFactor == Ogre::SBF_ZERO &&
              blendblock->mSourceBlendFactorAlpha == Ogre::SBF_ONE &&
              blendblock->mDestBlendFactorAlpha == Ogre::SBF_ZERO &&
              blendblock->mBlendOperation == Ogre::SBO_ADD &&
              blendblock->mBlendOperationAlpha == Ogre::SBO_ADD))
        {
            // It is not a default blendblock, so create a new blend node and set it in the pbs
            HlmsNodeBlendblock* blendnode = createBlendNode(mNodeEditor);
            blendnode->setBlendblockEnabled(true);
            blendnode->setAlphaToCoverageEnabled(blendblock->mAlphaToCoverageEnabled);
            switch (blendblock->mBlendChannelMask)
            {
                case Ogre::HlmsBlendblock::BlendChannelRed:
                    blendnode->setBlendChannelMask(0);
                break;
                case Ogre::HlmsBlendblock::BlendChannelGreen:
                    blendnode->setBlendChannelMask(1);
                break;
                case Ogre::HlmsBlendblock::BlendChannelBlue:
                    blendnode->setBlendChannelMask(2);
                break;
                case Ogre::HlmsBlendblock::BlendChannelAlpha:
                    blendnode->setBlendChannelMask(3);
                break;
                case Ogre::HlmsBlendblock::BlendChannelAll:
                    blendnode->setBlendChannelMask(4);
                break;
            }
            blendnode->setTransparent(blendblock->mIsTransparent);
            blendnode->setSeparateBlend(blendblock->mSeparateBlend);
            blendnode->setSourceBlendFactor(getIndexFromSceneBlendFactor(blendblock->mSourceBlendFactor));
            blendnode->setDestBlendFactor(getIndexFromSceneBlendFactor(blendblock->mDestBlendFactor));
            blendnode->setSourceBlendFactorAlpha(getIndexFromSceneBlendFactor(blendblock->mSourceBlendFactorAlpha));
            blendnode->setDestBlendFactorAlpha(getIndexFromSceneBlendFactor(blendblock->mDestBlendFactorAlpha));
            blendnode->setBlendOperation(getIndexFromSceneBlendOperation(blendblock->mBlendOperation));
            blendnode->setBlendOperationAlpha(getIndexFromSceneBlendOperation(blendblock->mBlendOperationAlpha));
            connectNodes(pbsnode, blendnode); // Connect both nodes
        }
    }

    return pbsnode;
}

//****************************************************************************/
HlmsNodePbsDatablock* HlmsPbsBuilder::createPbsNode(void)
{
    HlmsNodePbsDatablock* node = new HlmsNodePbsDatablock(NODE_TITLE_PBS_DATABLOCK);
    node->setType(NODE_TYPE_PBS_DATABLOCK);
    mNodeEditor->addNode(node);
    repositionPbsNode(node);
    return node;
}

//****************************************************************************/
void HlmsPbsBuilder::enrichPbsNode(HlmsNodePbsDatablock* pbsnode,
                                   Ogre::HlmsPbsDatablock* datablock)
{
    // ******** Name ********
    pbsnode->setName(datablock->getFullName()->c_str());

    // ******** Diffuse ********
    pbsnode->setDiffuseRed(255.0f * datablock->getDiffuse().x);
    pbsnode->setDiffuseGreen(255.0f * datablock->getDiffuse().y);
    pbsnode->setDiffuseBlue(255.0f * datablock->getDiffuse().z);

    // ******** Background diffuse ********
    pbsnode->setBackgroundDiffuseRed(255.0f * datablock->getBackgroundDiffuse().r);
    pbsnode->setBackgroundDiffuseGreen(255.0f * datablock->getBackgroundDiffuse().g);
    pbsnode->setBackgroundDiffuseBlue(255.0f * datablock->getBackgroundDiffuse().b);
    pbsnode->setBackgroundDiffuseAlpha(255.0f * datablock->getBackgroundDiffuse().a);

    // ******** Specular ********
    pbsnode->setSpecularRed(255.0f * datablock->getSpecular().x);
    pbsnode->setSpecularGreen(255.0f * datablock->getSpecular().y);
    pbsnode->setSpecularBlue(255.0f * datablock->getSpecular().z);

    // ******** Roughness ********
    pbsnode->setRoughness(datablock->getRoughness());

    // ******** Workflow ********
    unsigned int workflow;
    switch (datablock->getWorkflow())
    {
        case Ogre::HlmsPbsDatablock::SpecularWorkflow:
            workflow = 0;
        break;
        case Ogre::HlmsPbsDatablock::SpecularAsFresnelWorkflow:
            workflow = 1;
        break;
        case Ogre::HlmsPbsDatablock::MetallicWorkflow:
            workflow = 2;
        break;
    }
    pbsnode->setWorkflow(workflow);

    // ******** Metalness ********
    if (workflow == 2)
        pbsnode->setMetalness(datablock->getMetallness());

    // ******** Fresnel ********
    if (workflow != 2)
    {
        pbsnode->setFresnelRed(datablock->getFresnel().x);
        pbsnode->setFresnelGreen(datablock->getFresnel().y);
        pbsnode->setFresnelBlue(datablock->getFresnel().z);
        pbsnode->setSeparateFresnel(datablock->hasSeparateFresnel());
    }

    // ******** Transparency ********
    unsigned int transparencyMode;
    switch (datablock->getTransparencyMode())
    {
        case Ogre::HlmsPbsDatablock::None:
            transparencyMode = 0;
        break;
        case Ogre::HlmsPbsDatablock::Transparent:
            transparencyMode = 1;
        break;
        case Ogre::HlmsPbsDatablock::Fade:
            transparencyMode = 2;
        break;
    }
    pbsnode->setTransparencyMode(transparencyMode);
    pbsnode->setUseAlphaFromTexture(datablock->getUseAlphaFromTextures());
    pbsnode->setTransparencyValue(datablock->getTransparency());

    // ******** Two-sided lighting ********
    pbsnode->setTwoSidedLighting(datablock->getTwoSidedLighting());

    // ******** Brdf ********
    pbsnode->setBrdf(datablock->getBrdf());

    // ******** Alphatest ********
    pbsnode->setAlphaTest(getIndexFromCompareFunction(datablock->getAlphaTest()));

    // ******** Alphatest threshold ********
    pbsnode->setAlphaTestThreshold(datablock->getAlphaTestThreshold());
}

//****************************************************************************/
void HlmsPbsBuilder::enrichSamplerNode (HlmsNodeSamplerblock* samplernode,
                                        Ogre::HlmsPbsDatablock* datablock,
                                        const HlmsUtilsManager::DatablockStruct& datablockStruct,
                                        Ogre::PbsTextureTypes textureType)
{
    if (!samplernode)
        return;

    if (!datablock)
        return;

    const Ogre::HlmsSamplerblock* samplerblock = datablock->getSamplerblock(textureType);
    if (!samplerblock)
        return;

    // ******** Texture (name) ********
    // Getting the filename of the texture
    Ogre::String basename = datablockStruct.textureMap[textureType];
    if (basename.empty())
    {
        QMessageBox::information(0, QString("Error"), QString("Cannot find image file. Is the resource location present in " +
                                                              getResourcesCfg() +
                                                              QString("?")));
        return;
    }

    // Search the file and path
    Ogre::String filename;
    Ogre::String path;
    Ogre::FileInfoListPtr list = Ogre::ResourceGroupManager::getSingleton().listResourceFileInfo(Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME) ;
    Ogre::FileInfoList::iterator it;
    Ogre::FileInfoList::iterator itStart = list->begin();
    Ogre::FileInfoList::iterator itEnd = list->end();
    for(it = itStart; it != itEnd; ++it)
    {
        Ogre::FileInfo& fileInfo = (*it);
        if (fileInfo.basename == basename)
        {
            filename = fileInfo.filename;
            path = fileInfo.archive->getName();
            break;
        }
    }

    // ******** Texture ********
    samplernode->setFileNameTexture((path + "/" + basename).c_str());
    samplernode->setPathTexture(path.c_str());
    samplernode->setBaseNameTexture(basename.c_str());

    // ******** Texture type ********
    samplernode->setTextureType(getIndexFromTextureType(textureType));

    // ******** Generic attributes ********
    enrichSamplerNodeGeneric(samplernode, samplerblock);

    // ******** UV set ********
    // Not in case of environment maps
    Ogre::uint8 uvSource = 0;
    if (textureType < Ogre::NUM_PBSM_SOURCES)
        uvSource = datablock->getTextureUvSource(textureType);
    samplernode->setUvSet(uvSource);

    // ******** Blend mode ********
    unsigned int index = getDetailMapIndexFromTextureType(textureType);
    if (index < 999)
    {
        Ogre::PbsBlendModes blendMode = datablock->getDetailMapBlendMode(index);
        unsigned int listIndex = getIndexFromBlendMode(blendMode);
        samplernode->setBlendMode(listIndex);
    }

    // ******** Map weight ********
    index = getDetailMapIndexFromTextureType(textureType);
    if (index < 999)
    {
        // It is a detail (diffuse) map (index diffuse detail map [0..3])
        samplernode->setMapWeight(datablock->getDetailMapWeight(index));
    }
    else
    {
        index = getDetailNormalMapIndexFromTextureType(textureType);
        if (index < 999)
        {
            // It is a detail normal map (index normal detail map [0..3])
            samplernode->setMapWeight(datablock->getDetailNormalWeight(index));
        }
        else if (textureType == Ogre::PBSM_NORMAL)
        {
            // It is a normal map
            samplernode->setMapWeight(datablock->getNormalMapWeight());
        }
    }

    // ******** Offset and scale ********
    index = getDetailMapIndexFromTextureType(textureType);
    if (index < 999)
    {
        // It is a detail (diffuse) map index diffuse detail map [0..3])
        Ogre::Vector4 v4 = datablock->getDetailMapOffsetScale(index);
        QVector2D v2;
        v2.setX(v4.x);
        v2.setY(v4.y);
        samplernode->setOffset(v2);
        v2.setX(v4.z);
        v2.setY(v4.w);
        samplernode->setScale(v2);
    }
    else
    {
        index = getDetailNormalMapIndexForOffSetScale(textureType);
        if (index < 999)
        {
            // It is a detail normal map (index normal detail map [4..7])
            Ogre::Vector4 v4 = datablock->getDetailMapOffsetScale(index);
            QVector2D v2;
            v2.setX(v4.x);
            v2.setY(v4.y);
            samplernode->setOffset(v2);
            v2.setX(v4.z);
            v2.setY(v4.w);
            samplernode->setScale(v2);
        }
    }
}

//****************************************************************************/
HlmsNodeSamplerblock* HlmsPbsBuilder::createSamplerNode(Ogre::HlmsPbsDatablock* datablock,
                                                        HlmsNodePbsDatablock* pbsnode,
                                                        Ogre::PbsTextureTypes textureType)
{
    // The index cannot be 0 while the textureType is not a diffuse map; this prevents that
    // a samplernode is created that is not really a samplernode
    if (textureType != Ogre::PBSM_DIFFUSE && getIndexFromTextureType(textureType) == 0)
        return 0;

    Ogre::TexturePtr tex;
    HlmsNodeSamplerblock* samplernode = 0;
    tex = datablock->getTexture(textureType);
    if (!tex.isNull())
    {
        samplernode = createSamplerNode(mNodeEditor);
        connectNodes(pbsnode, samplernode); // Connect both nodes
    }

    return samplernode;
}

//****************************************************************************/
void HlmsPbsBuilder::repositionPbsNode(HlmsNodePbsDatablock* pbsnode)
{
    if (!pbsnode)
        return;

    // Reposition the pbs node (this is only done once)
    QPointF pos = pbsnode->pos();
    //pos.setY(pos.y() + 0.6f * pbsnode->getHeigth());
    pos.setY(-0.5 * pbsnode->getHeigth());
    pbsnode->setPos(pos);
}

//****************************************************************************/
void HlmsPbsBuilder::connectNodes(HlmsNodePbsDatablock* pbsnode,
                                  HlmsNodeSamplerblock* samplernode)
{
    if (!pbsnode)
        return;

    if (!samplernode)
        return;

    // Connect pbs and sampler
    Magus::QtPort* portPbs = pbsnode->getFirstFreePort(PORT_ID_PBS_DATABLOCK, PORT_ID_PBS_DATABLOCK + 7); // Samplerblocks
    if (!portPbs)
        return;

    pbsnode->connectNode(PORT_ID_PBS_DATABLOCK,
                         PORT_ID_PBS_DATABLOCK + 7,
                         samplernode,
                         PORT_ID_SAMPLERBLOCK);

    // Reposition the sampler node
    QPointF pos = pbsnode->pos();
    pos.setX(pos.x() + pbsnode->getWidth() + 2 * portPbs->pos().y());
    pos.setY(-portPbs->pos().y());
    samplernode->setPos(pos);
}

//****************************************************************************/
void HlmsPbsBuilder::connectNodes(HlmsNodePbsDatablock* pbsnode,
                                  HlmsNodeMacroblock* macronode)
{
    if (!pbsnode)
        return;

    if (!macronode)
        return;

    // Connect pbs and macro
    Magus::QtPort* portPbs = pbsnode->getFirstFreePort(PORT_ID_PBS_DATABLOCK + 8, PORT_ID_PBS_DATABLOCK + 8); // Macroblock
    if (!portPbs)
        return;

    pbsnode->connectNode(PORT_MACROBLOCK, macronode, PORT_ID_MACROBLOCK);

    // Reposition the macro node
    QPointF pos = pbsnode->pos();
    pos.setX(pos.x() + 2 * pbsnode->getWidth());
    pos.setY(pos.y() - 0.1f * pbsnode->getHeigth());
    macronode->setPos(pos);
}

//****************************************************************************/
void HlmsPbsBuilder::connectNodes(HlmsNodePbsDatablock* pbsnode,
                                  HlmsNodeBlendblock* blendnode)
{
    if (!pbsnode)
        return;

    if (!blendnode)
        return;

    // Connect pbs and blend
    Magus::QtPort* portPbs = pbsnode->getFirstFreePort(PORT_ID_PBS_DATABLOCK + 9, PORT_ID_PBS_DATABLOCK + 9); // Blendblock
    if (!portPbs)
        return;

    pbsnode->connectNode(PORT_BLENDBLOCK, blendnode, PORT_ID_BLENDBLOCK);

    // Reposition the blend node
    QPointF pos = pbsnode->pos();
    pos.setX(pos.x() + pbsnode->getWidth() + portPbs->pos().y());
    pos.setY(pos.y() + 0.1 * pbsnode->getHeigth());
    blendnode->setPos(pos);
}

//****************************************************************************/
void HlmsPbsBuilder::enrichPbsDatablock(Ogre::HlmsPbsDatablock* datablock,
                                              HlmsNodePbsDatablock* pbsnode)
{
    // ******** Diffuse ********
    Ogre::Vector3 colour;
    colour.x = (float)pbsnode->getDiffuseRed() / 255.0f;
    colour.y = (float)pbsnode->getDiffuseGreen() / 255.0f;
    colour.z = (float)pbsnode->getDiffuseBlue() / 255.0f;
    datablock->setDiffuse(colour);

    // ******** Background diffuse ********
    Ogre::ColourValue colourValue;
    colourValue.r = (float)pbsnode->getBackgroundDiffuseRed() / 255.0f;
    colourValue.g = (float)pbsnode->getBackgroundDiffuseGreen() / 255.0f;
    colourValue.b = (float)pbsnode->getBackgroundDiffuseBlue() / 255.0f;
    colourValue.a = (float)pbsnode->getBackgroundDiffuseAlpha() / 255.0f;
    datablock->setBackgroundDiffuse(colourValue);

    // ******** Specular ********
    colour.x = (float)pbsnode->getSpecularRed() / 255.0f;
    colour.y = (float)pbsnode->getSpecularGreen() / 255.0f;
    colour.z = (float)pbsnode->getSpecularBlue() / 255.0f;
    datablock->setSpecular(colour);

    // ******** Roughness ********
    datablock->setRoughness(pbsnode->getRoughness());

    // ******** Workflow ********
    Ogre::HlmsPbsDatablock::Workflows workflow;
    switch (pbsnode->getWorkflow())
    {
        case 0:
            workflow = Ogre::HlmsPbsDatablock::SpecularWorkflow;
        break;
        case 1:
            workflow = Ogre::HlmsPbsDatablock::SpecularAsFresnelWorkflow;
        break;
        case 2:
            workflow = Ogre::HlmsPbsDatablock::MetallicWorkflow;
        break;
    }
    datablock->setWorkflow(workflow);

    // ******** Metalness ********
    if (workflow == Ogre::HlmsPbsDatablock::MetallicWorkflow)
        datablock->setMetallness(pbsnode->getMetalness());

    // ******** Fresnel ********
    if (workflow != Ogre::HlmsPbsDatablock::MetallicWorkflow)
    {
        Ogre::Vector3 fresnel;
        fresnel.x = pbsnode->getFresnelRed();
        fresnel.y = pbsnode->getFresnelGreen();
        fresnel.z = pbsnode->getFresnelBlue();
        datablock->setFresnel(fresnel, pbsnode->isSeparateFresnel());
    }

    // ******** Transparency ********
    Ogre::HlmsPbsDatablock::TransparencyModes transparencyMode;
    switch (pbsnode->getTransparencyMode())
    {
        case 0:
            transparencyMode = Ogre::HlmsPbsDatablock::None;
        break;
        case 1:
            transparencyMode = Ogre::HlmsPbsDatablock::Transparent;
        break;
        case 2:
            transparencyMode = Ogre::HlmsPbsDatablock::Fade;
        break;
    }
    datablock->setTransparency(pbsnode->getTransparencyValue(),
                               transparencyMode,
                               pbsnode->isUseAlphaFromTexture(),
                               true);

    // ******** Two-sided lighting ********
    datablock->setTwoSidedLighting(pbsnode->isTwoSidedLighting());

    // ******** Brdf ********
    datablock->setBrdf(getBrdfFromIndex(pbsnode->getBrdf()));

    // ******** Alphatest threshold ********
    datablock->setAlphaTest(getCompareFunctionFromIndex(pbsnode->getAlphaTest()));

    // ******** Alphatest threshold ********
    datablock->setAlphaTestThreshold(pbsnode->getAlphaTestThreshold());
}

//****************************************************************************/
void HlmsPbsBuilder::enrichSamplerblock (Ogre::HlmsPbsDatablock* datablock,
                                         Ogre::HlmsSamplerblock* samplerblock,
                                         HlmsNodeSamplerblock* samplernode)
{
    // ******** Generic properties ********
    enrichSamplerBlockGeneric(samplerblock, samplernode);

    // ******** UV set ********
    // Don't set it for environment maps
    Ogre::PbsTextureTypes textureType = getPbsTextureTypeFromSamplerNode(samplernode);
    if (textureType < Ogre::NUM_PBSM_SOURCES)
        datablock->setTextureUvSource(textureType, samplernode->getUvSet());


    // ******** Blend mode ********
    Ogre::PbsBlendModes blendMode = getBlendModeFromIndex (samplernode->getBlendMode());
    unsigned int index = getDetailMapIndexFromTextureType(textureType);
    if (index < 999)
    {
        // It is a detail map (index diffuse detail map [0..3])
        datablock->setDetailMapBlendMode(index, blendMode);
    }

    // ******** Map weight ********
    // First check the detailed map
    index = getDetailMapIndexFromTextureType(textureType);
    if (index < 999)
    {
        // It is a detail map (index diffuse detail map [0..3])
        datablock->setDetailMapWeight(index, samplernode->getMapWeight());
    }
    else
    {
        index = getDetailNormalMapIndexFromTextureType(textureType);
        if (index < 999)
        {
            // It is a detail normal map (index normal detail map [0..3])
            datablock->setDetailNormalWeight(index, samplernode->getMapWeight());
        }
        else if (textureType == Ogre::PBSM_NORMAL)
        {
            // Also a normal map can have a weight
            datablock->setNormalMapWeight(samplernode->getMapWeight());
        }
    }

    // ******** Offset, scale ********
    // First check the detailed map
    index = getDetailMapIndexFromTextureType(textureType);
    if (index < 999)
    {
        // It is a detail map (index diffuse detail map [0..3])
        Ogre::Vector4 v4;
        v4.x = samplernode->getOffset().x();
        v4.y = samplernode->getOffset().y();
        v4.z = samplernode->getScale().x();
        v4.w = samplernode->getScale().y();
        datablock->setDetailMapOffsetScale(index, v4);
    }
    else
    {
        index = getDetailNormalMapIndexForOffSetScale(textureType);
        if (index < 999)
        {
            // It is a detail normal map  (index normal detail map [4..7])
            Ogre::Vector4 v4;
            v4.x = samplernode->getOffset().x();
            v4.y = samplernode->getOffset().y();
            v4.z = samplernode->getScale().x();
            v4.w = samplernode->getScale().y();
            datablock->setDetailMapOffsetScale(index, v4);
        }
    }
}

//****************************************************************************/
unsigned int HlmsPbsBuilder::getDetailMapIndexFromTextureType (Ogre::PbsTextureTypes textureType)
{
    switch (textureType)
    {
        case Ogre::PBSM_DETAIL0:
            return 0;
        break;
        case Ogre::PBSM_DETAIL1:
            return 1;
        break;
        case Ogre::PBSM_DETAIL2:
            return 2;
        break;
        case Ogre::PBSM_DETAIL3:
            return 3;
        break;
    }
    return 999;
}

//****************************************************************************/
unsigned int HlmsPbsBuilder::getDetailNormalMapIndexFromTextureType (Ogre::PbsTextureTypes textureType)
{
    switch (textureType)
    {
        case Ogre::PBSM_DETAIL0_NM:
            return 0;
        break;
        case Ogre::PBSM_DETAIL1_NM:
            return 1;
        break;
        case Ogre::PBSM_DETAIL2_NM:
            return 2;
        break;
        case Ogre::PBSM_DETAIL3_NM:
            return 3;
        break;
    }
    return 999;
}

//****************************************************************************/
unsigned int HlmsPbsBuilder::getDetailNormalMapIndexForOffSetScale (Ogre::PbsTextureTypes textureType)
{
    switch (textureType)
    {
        case Ogre::PBSM_DETAIL0_NM:
            return 4;
        break;
        case Ogre::PBSM_DETAIL1_NM:
            return 5;
        break;
        case Ogre::PBSM_DETAIL2_NM:
            return 6;
        break;
        case Ogre::PBSM_DETAIL3_NM:
            return 7;
        break;
    }
    return 999;
}

//****************************************************************************/
unsigned int HlmsPbsBuilder::getIndexFromBlendMode (Ogre::PbsBlendModes blendMode)
{
    switch (blendMode)
    {
        case Ogre::PBSM_BLEND_NORMAL_NON_PREMUL:
            return 0;
        break;
        case Ogre::PBSM_BLEND_NORMAL_PREMUL:
            return 1;
        break;
        case Ogre::PBSM_BLEND_ADD:
            return 2;
        break;
        case Ogre::PBSM_BLEND_SUBTRACT:
            return 3;
        break;
        case Ogre::PBSM_BLEND_MULTIPLY:
            return 4;
        break;
        case Ogre::PBSM_BLEND_MULTIPLY2X:
            return 5;
        break;
        case Ogre::PBSM_BLEND_SCREEN:
            return 6;
        break;
        case Ogre::PBSM_BLEND_OVERLAY:
            return 7;
        break;
        case Ogre::PBSM_BLEND_LIGHTEN:
            return 8;
        break;
        case Ogre::PBSM_BLEND_DARKEN:
            return 9;
        break;
        case Ogre::PBSM_BLEND_GRAIN_EXTRACT:
            return 10;
        break;
        case Ogre::PBSM_BLEND_GRAIN_MERGE:
            return 11;
        break;
        case Ogre::PBSM_BLEND_DIFFERENCE:
            return 12;
        break;
    }
    return 999;
}

//****************************************************************************/
Ogre::PbsBlendModes HlmsPbsBuilder::getBlendModeFromIndex (unsigned int index)
{
    switch (index)
    {
        case 0:
            return Ogre::PBSM_BLEND_NORMAL_NON_PREMUL;
        break;
        case 1:
            return Ogre::PBSM_BLEND_NORMAL_PREMUL;
        break;
        case 2:
            return Ogre::PBSM_BLEND_ADD;
        break;
        case 3:
            return Ogre::PBSM_BLEND_SUBTRACT;
        break;
        case 4:
            return Ogre::PBSM_BLEND_MULTIPLY;
        break;
        case 5:
            return Ogre::PBSM_BLEND_MULTIPLY2X;
        break;
        case 6:
            return Ogre::PBSM_BLEND_SCREEN;
        break;
        case 7:
            return Ogre::PBSM_BLEND_OVERLAY;
        break;
        case 8:
            return Ogre::PBSM_BLEND_LIGHTEN;
        break;
        case 9:
            return Ogre::PBSM_BLEND_DARKEN;
        break;
        case 10:
            return Ogre::PBSM_BLEND_GRAIN_EXTRACT;
        break;
        case 11:
            return Ogre::PBSM_BLEND_GRAIN_MERGE;
        break;
        case 12:
            return Ogre::PBSM_BLEND_DIFFERENCE;
        break;
    }
    return Ogre::PBSM_BLEND_NORMAL_NON_PREMUL;
}

//****************************************************************************/
Ogre::PbsBrdf::PbsBrdf HlmsPbsBuilder::getBrdfFromIndex (unsigned int index)
{
    switch (index)
    {
        case 0:
            return Ogre::PbsBrdf::Default;
        break;
        case 1:
            return Ogre::PbsBrdf::CookTorrance;
        break;
        case 2:
            return Ogre::PbsBrdf::DefaultUncorrelated;
        break;
        case 3:
            return Ogre::PbsBrdf::DefaultSeparateDiffuseFresnel;
        break;
        case 4:
            return Ogre::PbsBrdf::CookTorranceSeparateDiffuseFresnel;
        break;
    }
    return Ogre::PbsBrdf::Default;
}

//****************************************************************************/
unsigned int HlmsPbsBuilder::getIndexFromTextureType(Ogre::PbsTextureTypes textureType)
{
    switch (textureType)
    {
        case Ogre::PBSM_DIFFUSE:
            return 0;
        break;
        case Ogre::PBSM_NORMAL:
            return 1;
        break;
        case Ogre::PBSM_SPECULAR:
            return 2;
        break;
        case Ogre::PBSM_ROUGHNESS:
            return 3;
        break;
        case Ogre::PBSM_DETAIL_WEIGHT:
            return 4;
        break;
        case Ogre::PBSM_DETAIL0:
            return 5;
        break;
        case Ogre::PBSM_DETAIL1:
            return 6;
        break;
        case Ogre::PBSM_DETAIL2:
            return 7;
        break;
        case Ogre::PBSM_DETAIL3:
            return 8;
        break;
        case Ogre::PBSM_DETAIL0_NM:
            return 9;
        break;
        case Ogre::PBSM_DETAIL1_NM:
            return 10;
        break;
        case Ogre::PBSM_DETAIL2_NM:
            return 11;
        break;
        case Ogre::PBSM_DETAIL3_NM:
            return 12;
        break;
        case Ogre::PBSM_REFLECTION:
            return 13;
        break;
    }
    return 0;
}

//****************************************************************************/
Ogre::PbsTextureTypes HlmsPbsBuilder::getPbsTextureTypeFromSamplerNode(HlmsNodeSamplerblock* samplernode)
{
    unsigned int index = samplernode->getTextureType();
    switch (index)
    {
        case 0:
            return Ogre::PBSM_DIFFUSE;
        break;
        case 1:
            return Ogre::PBSM_NORMAL;
        break;
        case 2:
            return Ogre::PBSM_SPECULAR;
        break;
        case 3:
            return Ogre::PBSM_ROUGHNESS;
        break;
        case 4:
            return Ogre::PBSM_DETAIL_WEIGHT;
        break;
        case 5:
            return Ogre::PBSM_DETAIL0;
        break;
        case 6:
            return Ogre::PBSM_DETAIL1;
        break;
        case 7:
            return Ogre::PBSM_DETAIL2;
        break;
        case 8:
            return Ogre::PBSM_DETAIL3;
        break;
        case 9:
            return Ogre::PBSM_DETAIL0_NM;
        break;
        case 10:
            return Ogre::PBSM_DETAIL1_NM;
        break;
        case 11:
            return Ogre::PBSM_DETAIL2_NM;
        break;
        case 12:
            return Ogre::PBSM_DETAIL3_NM;
        break;
        case 13:
            return Ogre::PBSM_REFLECTION;
        break;
    }
    return Ogre::PBSM_DIFFUSE;
}

//****************************************************************************/
Ogre::HlmsTextureManager::TextureMapType HlmsPbsBuilder::getTextureMapTypeFromPbsTextureTypes(Ogre::PbsTextureTypes textureType)
{
    switch (textureType)
    {
        case Ogre::PBSM_DIFFUSE:
            return Ogre::HlmsTextureManager::TEXTURE_TYPE_DIFFUSE;
        break;
        case Ogre::PBSM_NORMAL:
            return Ogre::HlmsTextureManager::TEXTURE_TYPE_NORMALS;
        break;
        case Ogre::PBSM_SPECULAR:
            return Ogre::HlmsTextureManager::TEXTURE_TYPE_DETAIL;
        break;
        //case Ogre::PBSM_METALLIC:
            //return Ogre::HlmsTextureManager::TEXTURE_TYPE_MONOCHROME;
        //break;
        case Ogre::PBSM_ROUGHNESS:
            return Ogre::HlmsTextureManager::TEXTURE_TYPE_DETAIL;
        break;
        case Ogre::PBSM_DETAIL0:
            return Ogre::HlmsTextureManager::TEXTURE_TYPE_DETAIL;
        break;
        case Ogre::PBSM_DETAIL1:
            return Ogre::HlmsTextureManager::TEXTURE_TYPE_DETAIL;
        break;
        case Ogre::PBSM_DETAIL2:
        return Ogre::HlmsTextureManager::TEXTURE_TYPE_DETAIL;
        break;
        case Ogre::PBSM_DETAIL3:
        return Ogre::HlmsTextureManager::TEXTURE_TYPE_DETAIL;
        break;
        case Ogre::PBSM_DETAIL0_NM:
        return Ogre::HlmsTextureManager::TEXTURE_TYPE_DETAIL_NORMAL_MAP;
        break;
        case Ogre::PBSM_DETAIL1_NM:
        return Ogre::HlmsTextureManager::TEXTURE_TYPE_DETAIL_NORMAL_MAP;
        break;
        case Ogre::PBSM_DETAIL2_NM:
            return Ogre::HlmsTextureManager::TEXTURE_TYPE_DETAIL_NORMAL_MAP;
        break;
        case Ogre::PBSM_DETAIL3_NM:
            return Ogre::HlmsTextureManager::TEXTURE_TYPE_DETAIL_NORMAL_MAP;
        break;
        case Ogre::PBSM_REFLECTION:
            return Ogre::HlmsTextureManager::TEXTURE_TYPE_ENV_MAP;
        break;
    }
    return Ogre::HlmsTextureManager::TEXTURE_TYPE_DIFFUSE;
}

//****************************************************************************/
Ogre::HlmsTextureManager::TextureMapType HlmsPbsBuilder::getTextureMapTypeFromSamplerNode(HlmsNodeSamplerblock* samplernode)
{
    unsigned int index = samplernode->getTextureType();
    switch (index)
    {
        case 0:
            return Ogre::HlmsTextureManager::TEXTURE_TYPE_DIFFUSE;
        break;
        case 1:
            return Ogre::HlmsTextureManager::TEXTURE_TYPE_NORMALS;
        break;
        case 2:
            return Ogre::HlmsTextureManager::TEXTURE_TYPE_DETAIL;
        break;
        case 3:
            return Ogre::HlmsTextureManager::TEXTURE_TYPE_MONOCHROME;
        break;
        case 4:
            return Ogre::HlmsTextureManager::TEXTURE_TYPE_DETAIL;
        break;
        case 5:
            return Ogre::HlmsTextureManager::TEXTURE_TYPE_DETAIL;
        break;
        case 6:
            return Ogre::HlmsTextureManager::TEXTURE_TYPE_DETAIL;
        break;
        case 7:
        return Ogre::HlmsTextureManager::TEXTURE_TYPE_DETAIL;
        break;
        case 8:
        return Ogre::HlmsTextureManager::TEXTURE_TYPE_DETAIL;
        break;
        case 9:
        return Ogre::HlmsTextureManager::TEXTURE_TYPE_DETAIL_NORMAL_MAP;
        break;
        case 10:
        return Ogre::HlmsTextureManager::TEXTURE_TYPE_DETAIL_NORMAL_MAP;
        break;
        case 11:
            return Ogre::HlmsTextureManager::TEXTURE_TYPE_DETAIL_NORMAL_MAP;
        break;
        case 12:
            return Ogre::HlmsTextureManager::TEXTURE_TYPE_DETAIL_NORMAL_MAP;
        break;
        case 13:
            return Ogre::HlmsTextureManager::TEXTURE_TYPE_ENV_MAP;
        break;
    }
    return Ogre::HlmsTextureManager::TEXTURE_TYPE_DIFFUSE;
}

//****************************************************************************/
bool HlmsPbsBuilder::isDetailMapOrDetailNormalMap (Ogre::PbsTextureTypes textureType)
{
    switch (textureType)
    {
        case Ogre::PBSM_DETAIL0:
            return true;
        break;
        case Ogre::PBSM_DETAIL1:
            return true;
        break;
        case Ogre::PBSM_DETAIL2:
            return true;
        break;
        case Ogre::PBSM_DETAIL3:
            return true;
        break;
        case Ogre::PBSM_DETAIL0_NM:
            return true;
        break;
        case Ogre::PBSM_DETAIL1_NM:
            return true;
        break;
        case Ogre::PBSM_DETAIL2_NM:
            return true;
        break;
        case Ogre::PBSM_DETAIL3_NM:
            return true;
        break;
    }
    return false;
}

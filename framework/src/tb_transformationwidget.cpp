/****************************************************************************
**
** Copyright (C) 2016
**
** This file is generated by the Magus toolkit
**
** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
** "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
** LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
** A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
** OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
** LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
** DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
** OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
**
****************************************************************************/

#include <QComboBox>
#include <QStringListModel>
#include <QLabel>
#include <QHBoxLayout>
#include <QGroupBox>
#include <QLineEdit>
#include "tb_transformationwidget.h"

namespace Magus
{
    //****************************************************************************/
    TransformationWidget::TransformationWidget(QWidget* parent) : QWidget(parent)
    {
        selectionChanged = false;
        mPrecision = 2;
        mPosition = QVector3D(0, 0, 0);
        mRotation = QVector3D(0, 0, 0);
        mScale = QVector3D(0, 0, 0);
        mTransformation = POSITION;
        QHBoxLayout* transformationLayout = new QHBoxLayout;
        QHBoxLayout* xLayout = new QHBoxLayout;
        QHBoxLayout* yLayout = new QHBoxLayout;
        QHBoxLayout* zLayout = new QHBoxLayout;

        // Combobox
        QStringList list;
        list << QString("Position") << QString("Rotation") << QString("Scale");
        mModel = new QStringListModel(list);
        mTransformationCombobox = new QComboBox(parent);
        mTransformationCombobox->setModel(mModel);
        mTransformationCombobox->setMaxVisibleItems(3);

        // X, Y, Z
        QString s;
        QLabel* xLabel = new QLabel(QString("<b>X</b>"));
        xLabel->setMaximumWidth(24);
        xLabel->setAutoFillBackground(true);
        xLabel->setStyleSheet("QLabel {background-color : rgb(255, 0, 0); margin-left: 0px; margin-right: 0px; spacing: 0px;}");
        QRegExp regularExpression("[+-]?([0-9]+\\.([0-9]+)?|\\.[0-9]+)([eE][+-]?[0-9]+)?"); // floating point
        QRegExpValidator* validator = new QRegExpValidator(regularExpression);
        mXedit = new QLineEdit;
        mXedit->setValidator(validator);
        s = QVariant(mPosition.x()).toString();
        s = s.left(getLeftStringIndex(s));
        mXedit->setText(s);
        mXedit->setStyleSheet("QLineEdit {margin-right: 0px; margin-left: 5px; width: 32px; spacing: 0px;}");

        QLabel* yLabel = new QLabel(QString("<b>Y</b>"));
        yLabel->setMaximumWidth(24);
        yLabel->setAutoFillBackground(true);
        yLabel->setStyleSheet("QLabel {background-color : rgb(0, 255, 0); margin-left: 0px; margin-right: 0px;}");
        mYedit = new QLineEdit;
        mYedit->setValidator(validator);
        s = QVariant(mPosition.y()).toString();
        s = s.left(getLeftStringIndex(s));
        mYedit->setText(s);
        mYedit->setStyleSheet("QLineEdit {margin-right: 0px; margin-left: 0px; width: 32px; spacing: 0px;}");

        QLabel* zLabel = new QLabel(QString("<b>Z</b>"));
        zLabel->setMaximumWidth(24);
        zLabel->setAutoFillBackground(true);
        zLabel->setStyleSheet("QLabel {background-color : rgb(100, 100, 255); margin-left: 0px; margin-right: 0px;}");
        mZedit = new QLineEdit;
        mZedit->setValidator(validator);
        s = QVariant(mPosition.z()).toString();
        s = s.left(getLeftStringIndex(s));
        mZedit->setText(s);
        mZedit->setStyleSheet("QLineEdit {margin-right: 0px; margin-left: 0px; width: 32px; spacing: 0px;}");

        // Layout
        transformationLayout->addWidget(mTransformationCombobox);
        xLayout->addWidget(xLabel, 0, Qt::AlignRight);
        xLayout->addWidget(mXedit, 100, Qt::AlignLeft);
        yLayout->addWidget(yLabel, 0, Qt::AlignRight);
        yLayout->addWidget(mYedit, 0, Qt::AlignLeft);
        zLayout->addWidget(zLabel, 0, Qt::AlignRight);
        zLayout->addWidget(mZedit, 0, Qt::AlignLeft);
        transformationLayout->addLayout(xLayout);
        transformationLayout->addLayout(yLayout);
        transformationLayout->addLayout(zLayout);
        setLayout(transformationLayout);
        connect(mTransformationCombobox, SIGNAL(currentIndexChanged(int)), this, SLOT(handleSelectionChanged(int)));
        connect(mXedit, SIGNAL(textEdited(const QString &)), this, SLOT(handleXchanged(const QString &)));
        connect(mYedit, SIGNAL(textEdited(const QString &)), this, SLOT(handleYchanged(const QString &)));
        connect(mZedit, SIGNAL(textEdited(const QString &)), this, SLOT(handleZchanged(const QString &)));
    }

    //****************************************************************************/
    TransformationWidget::~TransformationWidget(void)
    {
    }

    //****************************************************************************/
    void TransformationWidget::handleSelectionChanged(int index)
    {
        if (!mXedit || !mYedit || !mZedit)
            return;

        selectionChanged = true;
        QString s;
        unsigned int i;
        switch (index)
        {
            case 0:
            {
                mTransformation = POSITION; // Must be changed before the edit widgets are set
                s = QVariant(mPosition.x()).toString();
                s = s.left(getLeftStringIndex(s));
                mXedit->setText(s);
                s = QVariant(mPosition.y()).toString();
                s = s.left(getLeftStringIndex(s));
                mYedit->setText(s);
                s = QVariant(mPosition.z()).toString();
                s = s.left(getLeftStringIndex(s));
                mZedit->setText(s);
            }
            break;

            case 1:
            {
                mTransformation = ROTATION; // Must be changed before the edit widgets are set
                s = QVariant(mRotation.x()).toString();
                s = s.left(getLeftStringIndex(s));
                mXedit->setText(s);
                s = QVariant(mRotation.y()).toString();
                s = s.left(getLeftStringIndex(s));
                mYedit->setText(s);
                s = QVariant(mRotation.z()).toString();
                s = s.left(getLeftStringIndex(s));
                mZedit->setText(s);
            }
            break;

            case 2:
            {
                mTransformation = SCALE; // Must be changed before the edit widgets are set
                s = QVariant(mScale.x()).toString();
                s = s.left(getLeftStringIndex(s));
                mXedit->setText(s);
                s = QVariant(mScale.y()).toString();
                s = s.left(getLeftStringIndex(s));
                mYedit->setText(s);
                s = QVariant(mScale.z()).toString();
                s = s.left(getLeftStringIndex(s));
                mZedit->setText(s);
            }
            break;
        }
        selectionChanged = false;
    }

    //****************************************************************************/
    void TransformationWidget::sync(void)
    {
        if (selectionChanged)
            return;

        if (!mXedit || !mYedit || !mZedit)
            return;

        float x = mXedit->text().toFloat();
        float y = mYedit->text().toFloat();
        float z = mZedit->text().toFloat();
        switch (mTransformation)
        {
            case POSITION:
            {
                mPosition.setX(x);
                mPosition.setY(y);
                mPosition.setZ(z);
            }
            break;

            case ROTATION:
            {
                mRotation.setX(x);
                mRotation.setY(y);
                mRotation.setZ(z);
            }
            break;

            case SCALE:
            {
                mScale.setX(x);
                mScale.setY(y);
                mScale.setZ(z);
            }
            break;
        }
        emit valueChanged();
    }

    //****************************************************************************/
    void TransformationWidget::handleXchanged(const QString &x)
    {
        sync();
    }

    //****************************************************************************/
    void TransformationWidget::handleYchanged(const QString &y)
    {
        sync();
    }

    //****************************************************************************/
    void TransformationWidget::handleZchanged(const QString &z)
    {
        sync();
    }

    //****************************************************************************/
    const TransformationWidget::Transformation TransformationWidget::getCurrentTransformation(void) const
    {
        return mTransformation;
    }

    //****************************************************************************/
    const QVector3D TransformationWidget::getCurrentXYZ(void)
    {
        switch (mTransformation)
        {
            case POSITION:
            {
                return mPosition;
            }
            break;

            case ROTATION:
            {
                return mRotation;
            }
            break;

            case SCALE:
            {
                return mScale;
            }
            break;
        }

        return mPosition;
    }

    //****************************************************************************/
    const QVector3D TransformationWidget::getPosition(void) const
    {
        return mPosition;
    }

    //****************************************************************************/
    const QVector3D TransformationWidget::getRotation(void) const
    {
        return mRotation;
    }

    //****************************************************************************/
    const QVector3D TransformationWidget::getScale(void) const
    {
        return mScale;
    }

    //****************************************************************************/
    void TransformationWidget::setPosition(const QVector3D& position)
    {
        mPosition = position;
        if (mTransformation == POSITION)
            handleSelectionChanged(0);
    }

    //****************************************************************************/
    void TransformationWidget::setRotation(const QVector3D& rotation)
    {
        mRotation = rotation;
        if (mTransformation == ROTATION)
            handleSelectionChanged(1);
    }

    //****************************************************************************/
    void TransformationWidget::setScale(const QVector3D& scale)
    {
        mScale = scale;
        if (mTransformation == SCALE)
            handleSelectionChanged(2);
    }

    //****************************************************************************/
    void TransformationWidget::setListEnabled(bool enabled)
    {
        mTransformationCombobox->setEnabled(enabled);
    }

    //****************************************************************************/
    void TransformationWidget::setCurrentIndex(unsigned int index)
    {
        mTransformationCombobox->setCurrentIndex(index);
    }

    //****************************************************************************/
    unsigned int TransformationWidget::getLeftStringIndex(const QString& s)
    {
        unsigned int index = s.lastIndexOf(".");
        if (index == -1)
            index = s.length() + 1;
        else
            index += 1 + mPrecision;

        return index;
    }
}

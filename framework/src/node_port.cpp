/****************************************************************************
**
** Copyright (C) 2016
**
** This file is generated by the Magus toolkit
**
** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
** "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
** LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
** A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
** OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
** LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
** DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
** OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
**
****************************************************************************/

// Include
#include <QMessageBox>
#include <QStyleOptionGraphicsItem>
#include <QLinearGradient>
#include <QPen>
#include <QBrush>
#include <QColor>
#include <QPainter>
#include <QPixmap>
#include "node_constants.h"
#include "node_port.h"
#include "node_node.h"

namespace Magus
{
    //****************************************************************************/
    QtPort::QtPort(unsigned int portId,
                   const QString& portName,
                   QtPortType portType,
                   QColor portColour,
                   QColor connectionColour,
                   QtPortShape portShape,
                   Alignment alignment,
                   qreal zoom,
                   QGraphicsItem* parent) : QGraphicsPathItem(parent)
    {
        mPortId = portId;
        mPortName = portName;
        mPortType = portType;
        mPortColour = portColour;
        mConnectionColour = connectionColour;
        mPortShape = portShape;
        mAlignment = alignment;
        mZoom = zoom;
        mParent = parent;
        mPortOpen = true;
        mConnection = 0;
        mCopyOfPort = 0;
        mConnectionIsBase = false;

        // Set default: Input and Output ports may only be connected to each other
        if (mPortType.mPortType == NODE_PORT_TYPE_INPUT)
        {
            QtOutputPortType outputPortType;
            mPortType.addPortTypeToConnectionPolicy(outputPortType);
        }
        else if (portType.mPortType == NODE_PORT_TYPE_OUTPUT)
        {
            QtInputPortType inputPortType;
            mPortType.addPortTypeToConnectionPolicy(inputPortType);
        }


        // Create label
        mLabel = new QGraphicsTextItem(this);
        mLabel->setPlainText(portName);

        QPen pen(portColour);
        pen.setWidth(mZoom * NODE_PORT_PEN_SIZE);
        setPen(pen);
        redraw();
    }

    //****************************************************************************/
    QtPort::~QtPort(void)
    {
    }

    //****************************************************************************/
    //****************************************************************************/
    void QtPort::setPortOpen(bool open)
    {
        mPortOpen = open;
        if (!open)
            setBrush(mPortColour);
        else
        {
            QColor col(QString("#000000ff"));
            setBrush(col);
        }
    }

    //****************************************************************************/
    void QtPort::setNameColor(const QColor& color)
    {
        mLabel->setDefaultTextColor(color);
    }

    //****************************************************************************/
    void QtPort::setZoom(qreal zoom)
    {
        mZoom = zoom;
    }

    //****************************************************************************/
    void QtPort::redraw(void)
    {
        mFont.setPointSize(mZoom * NODE_PORT_FONT_SIZE);
        mLabel->setFont(mFont);

        QPainterPath p;
        QPen pen(mPortColour);
        pen.setWidth(mZoom * NODE_PORT_PEN_SIZE);
        setPen(pen);
        qreal shapeSize = mZoom * NODE_PORT_SHAPE_SIZE;
        switch (mPortShape)
        {
            case PORT_SHAPE_CIRCLE:
            {
                p.addEllipse(-0.5f * shapeSize, -0.5f * shapeSize, shapeSize, shapeSize);
                setPath(p);
            }
            break;
            case PORT_SHAPE_SQUARE:
            {
                p.addRect(-0.5f * shapeSize, -0.5f * shapeSize, shapeSize, shapeSize);
                setPath(p);
            }
            break;
        }

        QPointF position = pos();
        setAlignedPos(position);
    }

    //****************************************************************************/
    qreal QtPort::getNormalizedWidth(void)
    {
        // Set the fontsize of the text to zoom = 1 and get the boundingRect().width() of the text and the shape
        mFont.setPointSize(NODE_PORT_FONT_SIZE);
        mLabel->setFont(mFont);
        qreal width = mLabel->boundingRect().width() + NODE_PORT_SHAPE_SIZE + NODE_PORT_WIDTH_MARGIN;
        mFont.setPointSize(mZoom * NODE_PORT_FONT_SIZE);
        mLabel->setFont(mFont);
        return width;
    }

    //****************************************************************************/
    qreal QtPort::getNormalizedHeight(void)
    {
        // Set the fontsize of the text to zoom = 1 and get the boundingRect().heigth() of the text and the shape
        mFont.setPointSize(NODE_PORT_FONT_SIZE);
        mLabel->setFont(mFont);
        qreal height = mLabel->boundingRect().height();
        if (height < NODE_PORT_SHAPE_SIZE)
            height = NODE_PORT_SHAPE_SIZE; // In case the text is smaller than the port shape
        mFont.setPointSize(mZoom * NODE_PORT_FONT_SIZE);
        mLabel->setFont(mFont);
        return height;
    }

    //****************************************************************************/
    void QtPort::setAlignedPos(const QPointF& pos)
    {
        if (mAlignment == ALIGNED_RIGHT)
        {
            mLabel->setPos(-mLabel->boundingRect().width() - mZoom * NODE_PORT_WIDTH_MARGIN, -0.5 * mLabel->boundingRect().height());
        }
        else
            mLabel->setPos(mZoom * NODE_PORT_WIDTH_MARGIN, -0.5 * mLabel->boundingRect().height());
        setPos(pos);
    }

    //****************************************************************************/
    void QtPort::setAlignedPos(qreal x, qreal y)
    {
        setAlignedPos(QPointF(x, y));
    }

    //****************************************************************************/
    QtConnection* QtPort::createConnection(QtConnection* targetConnection)
    {
        if (targetConnection)
        {
            // The port is not the base, but the target
            mConnection = targetConnection;
            targetConnection->setTargetPort(this);
            mConnectionIsBase = false;
        }
        else
        {
            // The port is the base
            // Note, that adding the connection to the scene is done on a higher level
            mConnection = new QtConnection(this); // Don't make it a child of port, but do provide the port as a baseport
            mConnection->setData(NODE_KEY_GRAPHIC_ITEM_TYPE, QVariant(NODE_VALUE_TYPE_CONNECTION));
            mConnection->setColor(mConnectionColour);
            mConnectionIsBase = true;
        }

        setPortOpen(false);
        return mConnection;
    }

    //****************************************************************************/
    void QtPort::setConnection(QtConnection* connection, bool base)
    {
        mConnection = connection;
        if (base)
        {
            if (connection)
            {
                mConnection->setBasePort(this);
                setPortOpen(false);
            }
            else
                setPortOpen(true);

            mConnectionIsBase = true;
        }
        else
        {
            if (connection)
            {
                mConnection->setTargetPort(this);
                setPortOpen(false);
            }
            else
                setPortOpen(true);

            mConnectionIsBase = false;
        }
    }

    //****************************************************************************/
    void QtPort::deleteConnection(void)
    {
        if (mConnection)
        {
            QtPort* basePort = mConnection->getBasePort();
            QtPort* targetPort = mConnection->getTargetPort();
            if (mConnectionIsBase)
            {
                // Inform the target port
                if (targetPort)
                    targetPort->informConnectionDeleted();
            }
            else
            {
                // 'This' port is the target port; call the base port to delete its connection
                basePort->deleteConnection();
            }
            mConnectionIsBase = false;
            mConnection = 0;
            setPortOpen(true);
        }
    }

    //****************************************************************************/
    void QtPort::informConnectionDeleted(void)
    {
        setPortOpen(true);
        mConnectionIsBase = false;
        mConnection = 0;
    }

    //****************************************************************************/
    QtConnection* QtPort::getConnection(void)
    {
        return mConnection;
    }

    //****************************************************************************/
    void QtPort::updateConnection(const QPointF& altTargetPos)
    {
        if (mConnection)
            mConnection->updatePath(altTargetPos);
    }

    //****************************************************************************/
    bool QtPort::isConnectionAllowed(QtPort* portToConnect)
    {
        if (portToConnect)
        {
            QtPortType pt = portToConnect->getPortType();
            if (mPortType.isConnectionAllowed(pt))
                return true;
        }

        return false;
    }

    //****************************************************************************/
    bool QtPort::isPortConnected(void)
    {
        return mConnection;
    }

    //****************************************************************************/
    bool QtPort::isBasePort(void)
    {
        if (mConnection)
            return (this == mConnection->getBasePort());

        return false;
    }
    \
    //****************************************************************************/
    bool QtPort::isTargetPort(void)
    {
        if (mConnection)
            return (this == mConnection->getTargetPort());

        return false;
    }

    //****************************************************************************/
    void QtPort::collapse(void)
    {
        setVisible(false);
        mOriginalPos = pos() / mZoom;
        qreal y = 0.5 * parentItem()->boundingRect().height();
        setAlignedPos(mZoom * mOriginalPos.x(), y);
        if (mConnection)
        {
            mConnection->setZValue(-1);
            mConnection->updatePath(pos());
        }

        // Hide and move endpoint of the connection
        /*
        setVisible(false);
        mOriginalPos = pos();
        qreal y = 0.5 * parentItem()->boundingRect().height();
        setAlignedPos(mOriginalPos.x(), y);
        if (mConnection)
        {
            mConnection->setZValue(-1);
            mConnection->updatePath(pos());
        }
        */
    }

    //****************************************************************************/
    void QtPort::expand(void)
    {
        setVisible(true);
        setAlignedPos(mZoom * mOriginalPos);
        if (mConnection)
        {
            mConnection->setZValue(1);
            mConnection->updatePath(pos());
        }
        /*
        setVisible(true);
        setAlignedPos(mOriginalPos);
        if (mConnection)
        {
            mConnection->setZValue(1);
            mConnection->updatePath(pos());
        }
        */
    }

    //****************************************************************************/
    void QtPort::setCopyOfPort(QtPort* port)
    {
        mCopyOfPort = port;
    }

}

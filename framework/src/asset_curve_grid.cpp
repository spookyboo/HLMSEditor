/****************************************************************************
**
** Copyright (C) 2016
**
** This file is generated by the Magus toolkit
**
** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
** "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
** LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
** A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
** OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
** LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
** DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
** OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
**
****************************************************************************/

// Include
#include <QGraphicsTextItem>
#include <QMessageBox>
#include <QtGlobal>
#include <QLinearGradient>
#include "asset_curve_grid.h"

namespace Magus
{
    //****************************************************************************/
    QtCurveEllipseItem::QtCurveEllipseItem(qreal x, qreal y, qreal w, qreal h) :
        QGraphicsEllipseItem(x, y, w, h)
    {
        setAcceptHoverEvents(true);
        setAcceptedMouseButtons(Qt::LeftButton | Qt::RightButton);
        mSelected = false;
        mMouseOver = false;
        mPenUnselected = QPen(QString("#945555"));
        mPenSelected = QPen(QString("#ffff00"));

        QLinearGradient linearGradUnselected(0, 0, QtCurveGrid::POINT_SIZE, QtCurveGrid::POINT_SIZE);
        linearGradUnselected.setColorAt(0, QColor("#ff0000"));
        linearGradUnselected.setColorAt(0.99, QColor("#ffffff"));
        mBrushUnselected = QBrush(linearGradUnselected);

        QLinearGradient linearGradSelected(0, 0, QtCurveGrid::POINT_SIZE, QtCurveGrid::POINT_SIZE);
        linearGradSelected.setColorAt(0, QColor("#ffff00"));
        linearGradSelected.setColorAt(0.99, QColor("#ffffff"));
        mBrushSelected = QBrush(linearGradSelected);

        setPen(mPenUnselected);
        setBrush(mBrushUnselected);
    }

    //****************************************************************************/
    QtCurveEllipseItem::~QtCurveEllipseItem(void)
    {
    }

    //****************************************************************************/
    void QtCurveEllipseItem::setSelected (bool selected)
    {
        mSelected = selected;
        if (mSelected)
        {
            setPen(mPenSelected);
            setBrush(mBrushSelected);
        }
        else
        {
            setPen(mPenUnselected);
            setBrush(mBrushUnselected);
        }
    }

    //****************************************************************************/
    bool QtCurveEllipseItem::isSelected (void)
    {
        return mSelected;
    }

    //****************************************************************************/
    void QtCurveEllipseItem::setMouseOver (bool mouseOver, qreal x, qreal y, int decimalX, int decimalY)
    {
        // Use the same pen and brush for the mouseover
        mMouseOver = mouseOver;
        if (mMouseOver)
        {
            setPen(mPenSelected);
            setBrush(mBrushSelected);
            QString strX = QString::number(x, 'f', decimalX);
            QString strY = QString::number(y, 'f', decimalY);
            setToolTip(strX + QString(", ") + strY);
        }
        else
        {
            setPen(mPenUnselected);
            setBrush(mBrushUnselected);
        }
    }

    //****************************************************************************/
    bool QtCurveEllipseItem::isMouseOver (void)
    {
        return mMouseOver;
    }

    //****************************************************************************/
    void QtCurveEllipseItem::mousePressEvent(QGraphicsSceneMouseEvent* event)
    {
        //QMessageBox::information(0, QString("test"), "Press"); // TEST
    }

    //****************************************************************************/
    void QtCurveEllipseItem::hoverEnterEvent(QGraphicsSceneHoverEvent* event)
    {
        QMessageBox::information(0, QString("test"), "Enter"); // TEST
    }

    //****************************************************************************/
    void QtCurveEllipseItem::hoverLeaveEvent(QGraphicsSceneHoverEvent* event)
    {
        //QMessageBox::information(0, QString("test"), "Leave"); // TEST
    }


    //****************************************************************************/
    //****************************************************************************/
    //****************************************************************************/
    QtCurveGrid::QtCurveGrid(QObject* parent) : QGraphicsScene (parent)
    {
        mStep = 30;
        mMinX = 0.0f;
        mStepX = 0.5f;
        mMinY = 0.0f;
        mStepY = 0.5f;
        mDecimalX = 1;
        mDecimalY = 1;
        mZoomStep = 10;
        mParentView = 0;
        mStartX = 0.0f;
        mStartY = 0.0f;
        mMode = EDIT;
        mDrawType = STRAIGHTLINE_UNSORTED;
        mRepaintStraightLineUnsorted = false;
        mRepaintStraightLineSorted = false;
        mRepaintCubicUnsortedLine = false;
        mRepaintCubicUnsortedLine = false;
        mDrawStraightLineUnsortedPath = 0;
        mDrawStraightLineSortedPath = 0;
        mDrawCubicUnsortedLinePath = 0;
        mDrawCubicSortedLinePath = 0;
        mRubberBand = 0;
        mPointGroup = new QGraphicsItemGroup();
        addItem(mPointGroup);
    }

    //****************************************************************************/
    QtCurveGrid::~QtCurveGrid(void)
    {
        deletePoints();
        removeItem(mPointGroup);
        delete mPointGroup;
        deleteTextItems();
        if (mRubberBand)
        {
            removeItem(mRubberBand);
            delete mRubberBand;
        }
    }

    //****************************************************************************/
    void QtCurveGrid::addPoint(qreal x, qreal y)
    {
        QtCurveEllipseItem* item = new QtCurveEllipseItem(0, 0, POINT_SIZE, POINT_SIZE);
        addItem(item);
        item->setData(KEY_X, QVariant(x));
        item->setData(KEY_Y, QVariant(y));
        mPointList.append(item);
        mPointGroup->addToGroup(item);
        mRepaintStraightLineUnsorted = true;
        mRepaintStraightLineSorted = true;
        mRepaintCubicSortedLine = true;
        mRepaintCubicUnsortedLine = true;
    }

    //****************************************************************************/
    QVector <QPointF>& QtCurveGrid::getPoints(void)
    {
        mPoints.clear();
        QVectorIterator<QtCurveEllipseItem*> i(mPointList);
        QtCurveEllipseItem* item;
        i.toFront();
        qreal valX;
        qreal valY;
        if (mDrawType == STRAIGHTLINE_UNSORTED || mDrawType == CUBIC_UNSORTED)
        {
            // Unsorted types; just pass the points in the same order
            while (i.hasNext())
            {
                item = i.next();
                valX = QVariant(item->data(KEY_X)).toReal();
                valY = QVariant(item->data(KEY_Y)).toReal();
                QPointF p(valX, valY);
                mPoints.append(p);
            }
        }
        else
        {
            // Sorted types; sort the points first
            QMap<qreal, QPointF> sortedMap;
            while (i.hasNext())
            {
                item = i.next();
                valX = QVariant(item->data(KEY_X)).toReal();
                valY = QVariant(item->data(KEY_Y)).toReal();
                QPointF p(valX, valY);
                sortedMap[valX] = p;
            }
            QMapIterator<qreal, QPointF> j(sortedMap);
            while (j.hasNext())
            {
                j.next();
                QPointF p = j.value();
                mPoints.append(p);
            }
        }

        return mPoints;
    }

    //****************************************************************************/
    void QtCurveGrid::setMode (Mode mode)
    {
        mMode = mode;
    }

    //****************************************************************************/
    void QtCurveGrid::setDrawType (DrawType drawType)
    {
        mDrawType = drawType;
        switch(mDrawType)
        {
            case STRAIGHTLINE_UNSORTED:
            {
                mRepaintStraightLineUnsorted = true;
                drawStraightLineUnsorted();
                removeLineItem(STRAIGHTLINE_SORTED | CUBIC_UNSORTED | CUBIC_SORTED);
            }
            break;

            case STRAIGHTLINE_SORTED:
            {
                mRepaintStraightLineSorted = true;
                drawStraightLineSorted();
                removeLineItem(STRAIGHTLINE_UNSORTED | CUBIC_UNSORTED | CUBIC_SORTED);
            }
            break;

            case CUBIC_UNSORTED:
            {
                mRepaintCubicUnsortedLine = true;
                drawCubicUnsortedLine();
                removeLineItem(STRAIGHTLINE_UNSORTED | STRAIGHTLINE_SORTED | CUBIC_SORTED);
            }
            break;

            case CUBIC_SORTED:
            {
                mRepaintCubicSortedLine = true;
                drawCubicSortedLine();
                removeLineItem(STRAIGHTLINE_UNSORTED | STRAIGHTLINE_SORTED | CUBIC_UNSORTED);
            }
            break;
        }
    }

    //****************************************************************************/
    void QtCurveGrid::setParentView (QGraphicsView* parentView)
    {
        mParentView = parentView;
    }

    //****************************************************************************/
    inline qreal QtCurveGrid::round(qreal val, int step)
    {
       int tmp = int(val) + step /2;
       tmp -= tmp % step;
       return qreal(tmp);
    }

    //****************************************************************************/
    void QtCurveGrid::setStep(int step)
    {
        mStep = step;
        refresh();
    }

    //****************************************************************************/
    void QtCurveGrid::setXmin(qreal xMin)
    {
        mMinX = xMin;
        refresh();
    }

    //****************************************************************************/
    qreal QtCurveGrid::getXmin(void)
    {
        return mMinX;
    }

    //****************************************************************************/
    void QtCurveGrid::setXstep(qreal xStep)
    {
        mStepX = xStep;
        refresh();
    }

    //****************************************************************************/
    qreal QtCurveGrid::getXstep(void)
    {
        return mStepX;
    }

    //****************************************************************************/
    void QtCurveGrid::setDecimalX(int decimals)
    {
        mDecimalX = decimals;
        refresh();
    }

    //****************************************************************************/
    int QtCurveGrid::getDecimalX(void)
    {
        return mDecimalX;
    }

    //****************************************************************************/
    void QtCurveGrid::setYmin(qreal yMin)
    {
        mMinY = yMin;
        refresh();
    }

    //****************************************************************************/
    qreal QtCurveGrid::getYmin(void)
    {
        return mMinY;
    }

    //****************************************************************************/
    void QtCurveGrid::setYstep(qreal yStep)
    {
        mStepY = yStep;
        refresh();
    }

    //****************************************************************************/
    qreal QtCurveGrid::getYstep(void)
    {
        return mStepY;
    }

    //****************************************************************************/
    void QtCurveGrid::setDecimalY(int decimals)
    {
        mDecimalY = decimals;
        refresh();
    }

    //****************************************************************************/
    int QtCurveGrid::getDecimalY(void )
    {
        return mDecimalY;
    }

    //****************************************************************************/
    void QtCurveGrid::drawBackground(QPainter* painter, const QRectF& rect)
    {
        mStartX = round(rect.left(), mStep);
        mStartY = round(rect.bottom(), mStep);
        if (mStartX > rect.left())
        {
            mStartX -= mStep;
        }
        if (mStartY > rect.bottom())
        {
            mStartY -= mStep;
        }
        qreal xAxisBase = mStartY; // To plot the x-values near the x-axis
        qreal yAxisBase = mStartX; // To plot the y-values near the y-axis
        bool xAxisDraw = false;
        bool yAxisDraw = false;
        qreal yVal = mMinY;
        qreal xVal = mMinX;
        QString strVal;

        // Clear all text items
        clearTextFromTextItems();

        // Calculate where to position the y-values
        yAxisBase = mStartX - (mMinX / mStepX) * mStep;
        if (yAxisBase < rect.left())
            yAxisBase = rect.left();
        if (yAxisBase > rect.right() - mStep)
            yAxisBase = rect.right() - mStep;

        // Calculate where to position the x-values
        xAxisBase = mStartY - mStep + (mMinY / mStepY) * mStep;
        if (xAxisBase < rect.top())
            xAxisBase = rect.top();
        if (xAxisBase > rect.bottom())
            xAxisBase = rect.bottom() - mStep;

        // Set the default colour
        painter->setPen(QPen(QColor(200, 200, 255, 125)));

        // ------------------------- Draw the horizontal grid -------------------------
        QVectorIterator<QGraphicsTextItem*> i(mTextItemList);
        QGraphicsTextItem* label;
        i.toFront();
        for (qreal y = mStartY; y > rect.top();)
        {
            // Determine where the x-axis is
            if (!xAxisDraw && yVal > 0)
            {
                if (yVal <= 1.5 * mStepY)
                    painter->setPen(QPen(QColor(255, 255, 255, 255)));

                xAxisDraw = true;
            }
            else
            {
                painter->setPen(QPen(QColor(200, 200, 255, 125)));
            }

            // Set the text (value)
            if (i.hasNext())
            {
                label = i.next();
            }
            else
            {
                label = new QGraphicsTextItem();
                mTextItemList.append(label);
                addItem(label);
            }

            if (yVal > mStepY || yVal < mStepY)
            {
                // If y = 0 then don't show it on the grid
                strVal = QString::number(yVal - mStepY, 'f', mDecimalY);
                label->setPlainText(strVal);
            }
            int py = y;
            if (py < rect.top())
                py = rect.top();
            if (py > rect.bottom())
                py = rect.bottom() - mStep;
            label->setPos(yAxisBase, py - 6);
            label->mapToScene(yAxisBase, py - 6); // Do not draw labels outside the rect; this results in draw artifacts
            painter->drawLine(rect.left(), y, rect.right(), y);

            y -= mStep;
            yVal += mStepY;
        }

        // ------------------------- Draw the vertical grid -------------------------
        painter->setPen(QPen(QColor(200, 200, 255, 125)));
        for (qreal x = mStartX; x < rect.right();)
        {
            // Determine where the y-axis is
            if (!yAxisDraw && xVal > 0.0f)
            {
                if (xVal < 1.5 * mStepX)
                    painter->setPen(QPen(QColor(255, 255, 255, 255)));

                yAxisDraw = true;
            }
            else
            {
                painter->setPen(QPen(QColor(200, 200, 255, 125)));
            }

            // Set the text (value)
            if (i.hasNext())
            {
                label = i.next();
            }
            else
            {
                label = new QGraphicsTextItem();
                mTextItemList.append(label);
                addItem(label);
            }

            strVal = QString::number(xVal - mStepX, 'f', mDecimalX);
            label->setPlainText(strVal);
            int px = x;
            if (px < rect.left())
                label->setPlainText(QString("")); // Do not display text at the edges
            if (px > rect.right() - mStep)
                label->setPlainText(QString("")); // Do not display text at the edges
            label->setPos(px, xAxisBase);
            label->mapToScene(px, xAxisBase); // Do not draw labels outside the rect; this results in draw artifacts
            painter->drawLine(x, rect.top(), x, rect.bottom());

            x += mStep;
            xVal += mStepX;
        }

        // Draw the points and the line
        drawPoints();
        drawLine();
    }

    //****************************************************************************/
    void QtCurveGrid::clearTextFromTextItems(void)
    {
        QVectorIterator<QGraphicsTextItem*> i(mTextItemList);
        QGraphicsTextItem* label;
        i.toFront();
        while (i.hasNext())
        {
            label = i.next();
            label->setPlainText(QString(""));
        }
    }

    //****************************************************************************/
    void QtCurveGrid::drawPoints(void)
    {
        QVectorIterator<QtCurveEllipseItem*> i(mPointList);
        QtCurveEllipseItem* item;
        qreal valX;
        qreal valY;
        qreal pointX;
        qreal pointY;
        i.toFront();
        while (i.hasNext())
        {
            item = i.next();
            valX = QVariant(item->data(KEY_X)).toReal();
            valY = QVariant(item->data(KEY_Y)).toReal();
            pointX = mStartX + mStep - POINT_HALF_SIZE + ((valX - mMinX) / mStepX) * mStep;
            pointY = mStartY - mStep - POINT_HALF_SIZE -((valY - mMinY) / mStepY) * mStep;
            item->setPos(pointX, pointY);
            item->mapToScene(pointX, pointY);
        }
    }

    //****************************************************************************/
    void QtCurveGrid::drawLine(void)
    {
        switch(mDrawType)
        {
            case STRAIGHTLINE_UNSORTED:
                drawStraightLineUnsorted();
            break;

            case STRAIGHTLINE_SORTED:
                drawStraightLineSorted();
            break;

            case CUBIC_UNSORTED:
                drawCubicUnsortedLine();
            break;

            case CUBIC_SORTED:
                drawCubicSortedLine();
            break;
        }
    }

    //****************************************************************************/
    void QtCurveGrid::drawStraightLineUnsorted(void)
    {
        if (!mRepaintStraightLineUnsorted)
            return;

        if (mDrawStraightLineUnsortedPath)
            removeItem(mDrawStraightLineUnsortedPath);

        QVectorIterator<QtCurveEllipseItem*> i(mPointList);
        QtCurveEllipseItem* item;
        i.toFront();
        qreal valX;
        qreal valY;
        qreal pointX;
        qreal pointY;
        QPoint start;
        QPoint end;
        if (i.hasNext())
        {
            item = i.next();
            valX = QVariant(item->data(KEY_X)).toReal();
            valY = QVariant(item->data(KEY_Y)).toReal();
            pointX = fromXValueToPointX(valX);
            pointY = fromYValueToPointY(valY);
            start.setX((int)pointX);
            start.setY((int)pointY);
        };
        QPainterPath path(start);

        // Create the path
        while (i.hasNext())
        {
            item = i.next();
            valX = QVariant(item->data(KEY_X)).toReal();
            valY = QVariant(item->data(KEY_Y)).toReal();
            pointX = fromXValueToPointX(valX);
            pointY = fromYValueToPointY(valY);
            end.setX((int)pointX);
            end.setY((int)pointY);
            path.lineTo(end);
            end = start;
        }
        QPen pen(QString("#945555"));
        pen.setWidth(3);
        mDrawStraightLineUnsortedPath = addPath(path, pen);
        mRepaintStraightLineUnsorted = false;
    }

    //****************************************************************************/
    void QtCurveGrid::drawStraightLineSorted(void)
    {
        if (!mRepaintStraightLineSorted)
            return;

        if (mDrawStraightLineSortedPath)
            removeItem(mDrawStraightLineSortedPath);

        QVectorIterator<QtCurveEllipseItem*> i(mPointList);
        QMap<qreal, QPointF> sortedMap;
        QtCurveEllipseItem* item;
        qreal valX;
        qreal valY;
        qreal pointX;
        qreal pointY;
        QPoint start;
        QPoint end;

        // Put the points in a map
        i.toFront();
        while (i.hasNext())
        {
            item = i.next();
            valX = QVariant(item->data(KEY_X)).toReal();
            valY = QVariant(item->data(KEY_Y)).toReal();
            QPointF p(valX, valY);
            sortedMap[valX] = p;
        }

        // Create the path
        QMapIterator<qreal, QPointF> j(sortedMap);
        j.toFront();
        QPointF p;
        if (j.hasNext())
        {
            j.next();
            p = j.value();
            pointX = fromXValueToPointX(p.x());
            pointY = fromYValueToPointY(p.y());
            start.setX((int)pointX);
            start.setY((int)pointY);
        }
        QPainterPath path(start);

        while (j.hasNext())
        {
            j.next();
            p = j.value();
            pointX = fromXValueToPointX(p.x());
            pointY = fromYValueToPointY(p.y());
            end.setX((int)pointX);
            end.setY((int)pointY);
            path.lineTo(end);
            end = start;
        }
        QPen pen(QString("#945555"));
        pen.setWidth(3);
        mDrawStraightLineSortedPath = addPath(path, pen);
        mRepaintStraightLineSorted = false;
    }

    //****************************************************************************/
    void QtCurveGrid::drawCubicUnsortedLine(void)
    {
        if (!mRepaintCubicUnsortedLine)
            return;

        if (mDrawCubicUnsortedLinePath)
            removeItem(mDrawCubicUnsortedLinePath);

        QVectorIterator<QtCurveEllipseItem*> i(mPointList);
        QtCurveEllipseItem* item;
        i.toFront();
        qreal valX;
        qreal valY;
        qreal pointX;
        qreal pointY;
        QPoint start;
        QPoint mid;
        QPoint end;

        if (i.hasNext())
        {
            item = i.next();
            valX = QVariant(item->data(KEY_X)).toReal();
            valY = QVariant(item->data(KEY_Y)).toReal();
            pointX = fromXValueToPointX(valX);
            pointY = fromYValueToPointY(valY);
            start.setX((int)pointX);
            start.setY((int)pointY);
        }
        QPainterPath path(start);

        // Create the path
        while (i.hasNext())
        {
            if (i.hasNext())
            {
                item = i.next();
                valX = QVariant(item->data(KEY_X)).toReal();
                valY = QVariant(item->data(KEY_Y)).toReal();
                pointX = fromXValueToPointX(valX);
                pointY = fromYValueToPointY(valY);
                mid.setX((int)pointX);
                mid.setY((int)pointY);
            }
            if (i.hasNext())
            {
                item = i.next();
                valX = QVariant(item->data(KEY_X)).toReal();
                valY = QVariant(item->data(KEY_Y)).toReal();
                pointX = fromXValueToPointX(valX);
                pointY = fromYValueToPointY(valY);
                end.setX((int)pointX);
                end.setY((int)pointY);
                path.cubicTo(start, mid, end);
            }
            start = end;
        }
        QPen pen(QString("#945555"));
        pen.setWidth(3);
        mDrawCubicUnsortedLinePath = addPath(path, pen);
        mRepaintCubicUnsortedLine = false;
    }

    //****************************************************************************/
    void QtCurveGrid::drawCubicSortedLine(void)
    {
        if (!mRepaintCubicSortedLine)
            return;

        if (mDrawCubicSortedLinePath)
            removeItem(mDrawCubicSortedLinePath);

        QVectorIterator<QtCurveEllipseItem*> i(mPointList);
        QMap<qreal, QPointF> sortedMap;
        QtCurveEllipseItem* item;
        qreal valX;
        qreal valY;
        qreal pointX;
        qreal pointY;
        QPoint start;
        QPoint mid;
        QPoint end;

        // Put the points in a map
        i.toFront();
        while (i.hasNext())
        {
            item = i.next();
            valX = QVariant(item->data(KEY_X)).toReal();
            valY = QVariant(item->data(KEY_Y)).toReal();
            QPointF p(valX, valY);
            sortedMap[valX] = p;
        }

        QMapIterator<qreal, QPointF> j(sortedMap);
        j.toFront();
        QPointF p;
        if (j.hasNext())
        {
            j.next();
            p = j.value();
            pointX = fromXValueToPointX(p.x());
            pointY = fromYValueToPointY(p.y());
            start.setX((int)pointX);
            start.setY((int)pointY);
        }
        QPainterPath path(start);

        // Create the path
        while (j.hasNext())
        {
            if (j.hasNext())
            {
                j.next();
                p = j.value();
                pointX = fromXValueToPointX(p.x());
                pointY = fromYValueToPointY(p.y());
                mid.setX((int)pointX);
                mid.setY((int)pointY);
            }
            if (j.hasNext())
            {
                j.next();
                p = j.value();
                pointX = fromXValueToPointX(p.x());
                pointY = fromYValueToPointY(p.y());
                end.setX((int)pointX);
                end.setY((int)pointY);
                path.cubicTo(start, mid, end);
            }
            start = end;
        }
        QPen pen(QString("#945555"));
        pen.setWidth(3);
        mDrawCubicSortedLinePath = addPath(path, pen);
        mRepaintCubicSortedLine = false;
    }

    //****************************************************************************/
    void QtCurveGrid::wheelEvent (QWheelEvent* event)
    {
        if (event->delta() > 0)
            zoomOut();
        else
            zoomIn();
    }

    //****************************************************************************/
    void QtCurveGrid::zoomIn(void)
    {
        mStep += mZoomStep;
        refresh();
    }

    //****************************************************************************/
    void QtCurveGrid::zoomOut(void)
    {
        if (mStep - mZoomStep < 30)
           return;

        mStep -= mZoomStep;
        refresh();
    }

    //****************************************************************************/
    void QtCurveGrid::mousePressEvent(QGraphicsSceneMouseEvent* event)
    {
        // Left mousebutton
        if(event->buttons() & Qt::LeftButton)
        {
            mLastMousePosition.setX(event->lastScenePos().x());
            mLastMousePosition.setY(event->lastScenePos().y());
            if (mMode == EDIT)
            {
                qreal x = fromPointXToXValue((qreal)mLastMousePosition.x());
                qreal y = fromPointYToYValue((qreal)mLastMousePosition.y());
                addPoint(x, y);
                refresh();
            }
            else
            {
                // Run through points: Do it like this, because the mouse event on the QtCurveEllipseItem doesn't seem to work
                QVectorIterator<QtCurveEllipseItem*> i(mPointList);
                QtCurveEllipseItem* item;
                qreal valX;
                qreal valY;
                qreal pointX;
                qreal pointY;
                i.toFront();
                while (i.hasNext())
                {
                    item = i.next();
                    valX = QVariant(item->data(KEY_X)).toReal();
                    valY = QVariant(item->data(KEY_Y)).toReal();
                    pointX = fromXValueToPointX(valX);
                    pointY = fromYValueToPointY(valY);
                    if (mLastMousePosition.x() > pointX - POINT_HALF_SIZE &&
                        mLastMousePosition.x() < pointX + POINT_HALF_SIZE &&
                        mLastMousePosition.y() > pointY - POINT_HALF_SIZE &&
                        mLastMousePosition.y() < pointY + POINT_HALF_SIZE)
                    {
                        item->setSelected(!item->isSelected());
                    }
                }
            }
        }

        // Right mousebutton
        if(event->buttons() & Qt::RightButton)
        {
            // Deselect all points
            deselectAllPoints();
        }
        event->accept();
    }

    //****************************************************************************/
    void QtCurveGrid::mouseMoveEvent(QGraphicsSceneMouseEvent* event)
    {
        if(event->buttons() & Qt::LeftButton)
        {
            switch (mMode)
            {
                case MOVE:
                {
                    // Mouse is pressed and moves
                    qreal deltaX = ((qreal)mLastMousePosition.x() - event->lastScenePos().x()) / mStep;
                    qreal deltaY = ((qreal)mLastMousePosition.y() - event->lastScenePos().y()) / mStep;
                    if (atLeastOnePointSelected())
                    {
                        // Move only the selected point(s)
                        QVectorIterator<QtCurveEllipseItem*> i(mPointList);
                        QtCurveEllipseItem* item;
                        i.toFront();
                        qreal valX;
                        qreal valY;
                        while (i.hasNext())
                        {
                            item = i.next();
                            if (item->isSelected())
                            {
                                valX = QVariant(item->data(KEY_X)).toReal();
                                valY = QVariant(item->data(KEY_Y)).toReal();
                                valX -= (qreal)deltaX * mStepX;
                                valY += (qreal)deltaY * mStepY;
                                item->setData(KEY_X, QVariant(valX));
                                item->setData(KEY_Y, QVariant(valY));
                                mLastMousePosition.setX(event->lastScenePos().x());
                                mLastMousePosition.setY(event->lastScenePos().y());
                            }
                        }
                    }
                    else
                    {
                        // Move the whole grid
                        if (deltaX != 0 || deltaY != 0)
                        {
                            mMinX += deltaX * mStepX;
                            mMinY -= deltaY * mStepY;
                            mLastMousePosition.setX(event->lastScenePos().x());
                            mLastMousePosition.setY(event->lastScenePos().y());
                        }
                    }
                    refresh();
                }
                break;

                case SELECT:
                {
                    // Mouse is pressed and moves => draw rubberband
                    qreal x = event->lastScenePos().x();
                    qreal y = event->lastScenePos().y();
                    if (!mRubberBand)
                    {
                        mRubberBand = new QGraphicsRectItem(mLastMousePosition.x(), mLastMousePosition.y(), 0.0f, 0.0f);
                        mRubberBand->setPen(QPen(Qt::darkBlue));
                        QColor c(Qt::darkBlue);
                        c.setAlpha(64);
                        mRubberBand->setBrush(c);
                        addItem(mRubberBand);
                    }
                    mRubberBand->show();
                    qreal minX = qMin((qreal)mLastMousePosition.x(), x);
                    qreal maxX = qMax((qreal)mLastMousePosition.x(), x);
                    qreal minY = qMin((qreal)mLastMousePosition.y(), y);
                    qreal maxY = qMax((qreal)mLastMousePosition.y(), y);
                    mRubberBand->setRect(minX, minY, maxX - minX, maxY - minY);
                }
                break;
            }
        }

        // Mouseover: Do it on scenelevel, because the mouse events are not received on item-level (Why not!!!)
        checkMouseOver(event->lastScenePos().x(), event->lastScenePos().y());

        event->accept();
    }

    //****************************************************************************/
    void QtCurveGrid::mouseReleaseEvent(QGraphicsSceneMouseEvent* event)
    {
        if(event->button() & Qt::RightButton)
            return;

        switch (mMode)
        {
            case SELECT:
            {
                // Mouse is released; select all points in the rectangle
                if (mRubberBand)
                {
                    qreal minX = qMin((qreal)mLastMousePosition.x(), event->lastScenePos().x());
                    qreal maxX = qMax((qreal)mLastMousePosition.x(), event->lastScenePos().x());
                    qreal minY = qMin((qreal)mLastMousePosition.y(), event->lastScenePos().y());
                    qreal maxY = qMax((qreal)mLastMousePosition.y(), event->lastScenePos().y());
                    QVectorIterator<QtCurveEllipseItem*> i(mPointList);
                    QtCurveEllipseItem* item;
                    i.toFront();
                    qreal valX;
                    qreal valY;
                    qreal pointX;
                    qreal pointY;
                    while (i.hasNext())
                    {
                        item = i.next();
                        valX = QVariant(item->data(KEY_X)).toReal();
                        valY = QVariant(item->data(KEY_Y)).toReal();
                        pointX = fromXValueToPointX(valX);
                        pointY = fromYValueToPointY(valY);
                        if (pointX > minX && pointX < maxX && pointY > minY && pointY < maxY)
                        item->setSelected(true);
                    }

                    mRubberBand->hide();
                }
            }
            break;
        }
        event->accept();
    }

    //****************************************************************************/
    void QtCurveGrid::checkMouseOver(qreal x, qreal y)
    {
        // Mouseover: Do it on scenelevel, because the mouse events are not received on item-level
        QVectorIterator<QtCurveEllipseItem*> i(mPointList);
        QtCurveEllipseItem* item;
        i.toFront();
        qreal valX;
        qreal valY;
        qreal pointX;
        qreal pointY;
        while (i.hasNext())
        {
            item = i.next();
            valX = QVariant(item->data(KEY_X)).toReal();
            valY = QVariant(item->data(KEY_Y)).toReal();
            pointX = fromXValueToPointX(valX);
            pointY = fromYValueToPointY(valY);
            if (x > pointX - POINT_HALF_SIZE &&
                x < pointX + POINT_HALF_SIZE &&
                y > pointY - POINT_HALF_SIZE &&
                y < pointY + POINT_HALF_SIZE)
            {
                item->setMouseOver(true, valX, valY, mDecimalX, mDecimalY);
            }
            else
            {
                item->setMouseOver(false);
                item->setSelected(item->isSelected());
            }
        }
    }

    //****************************************************************************/
    void QtCurveGrid::refresh(void)
    {
        if (mParentView)
        {
            QWidget* viewport = mParentView->viewport();
            viewport->update();

            switch(mDrawType)
            {
                case STRAIGHTLINE_UNSORTED:
                {
                    mRepaintStraightLineUnsorted = true;
                }
                break;

                case STRAIGHTLINE_SORTED:
                {
                    mRepaintStraightLineSorted = true;
                }
                break;

                case CUBIC_UNSORTED:
                {
                    mRepaintCubicUnsortedLine = true;
                }
                break;

                case CUBIC_SORTED:
                {
                    mRepaintCubicSortedLine = true;
                }
                break;
            }
        }
    }

    //****************************************************************************/
    void QtCurveGrid::fitHorizontal(void)
    {
        qreal minX = FLT_MAX;
        qreal maxX = -FLT_MAX;
        qreal valX;
        QVectorIterator<QtCurveEllipseItem*> i(mPointList);
        QtCurveEllipseItem* item;
        i.toFront();
        while (i.hasNext())
        {
            item = i.next();
            valX = QVariant(item->data(KEY_X)).toReal();
            if (valX < minX)
                minX = valX;
            if (valX > maxX)
                maxX = valX;
        };

        // Set the new range
        mMinX = minX;
        mStepX = (maxX - minX) / (mParentView->width() / mStep - 1);
        refresh();
    }

    //****************************************************************************/
    void QtCurveGrid::fitVertical(void)
    {
        qreal minY = FLT_MAX;
        qreal maxY = -FLT_MAX;
        qreal valY;
        QVectorIterator<QtCurveEllipseItem*> i(mPointList);
        QtCurveEllipseItem* item;
        i.toFront();
        while (i.hasNext())
        {
            item = i.next();
            valY = QVariant(item->data(KEY_Y)).toReal();
            if (valY < minY)
                minY = valY;
            if (valY > maxY)
                maxY = valY;
        };

        // Set the new range
        mMinY = minY;
        mStepY = (maxY - minY) / (mParentView->height() / mStep - 1);
        refresh();
    }

    //****************************************************************************/
    void QtCurveGrid::deletePoints(void)
    {
        QtCurveEllipseItem* item;
        if (atLeastOnePointSelected())
        {
            // Remove selected points from scene
            QVector<QtCurveEllipseItem*>::iterator i = mPointList.begin(); // Use std-style iterator, because of erase
            while (i != mPointList.end())
            {
                item = *i;
                if (item->isSelected())
                {
                    mPointGroup->removeFromGroup(item); // removing individual items from the scene does not work properly!
                    i = mPointList.erase(i);
                    delete item;
                }
                else
                    i++;
            };
        }
        else
        {
            // Remove all points from scene
            removeItem(mPointGroup);
            QVectorIterator<QtCurveEllipseItem*> i(mPointList);
            i.toFront();
            if (i.hasNext())
            {
                item = i.next();
                mPointGroup->removeFromGroup(item); // removing individual items from the scene does not work properly!
                delete item;
            };
            mPointList.clear();
            mPointGroup = new QGraphicsItemGroup();
            addItem(mPointGroup);
        }
        refresh();
    }

    //****************************************************************************/
    void QtCurveGrid::deleteTextItems(void)
    {
        QVector<QGraphicsTextItem*>::iterator i = mTextItemList.begin(); // Use std-style iterator, because of erase
        QGraphicsTextItem* label;
        while (i != mTextItemList.end())
        {
            label = *i;
            removeItem(label);
            i = mTextItemList.erase(i);
            delete label;
            i++;
        }
    }

    //****************************************************************************/
    void QtCurveGrid::deselectAllPoints(void)
    {
        QVectorIterator<QtCurveEllipseItem*> i(mPointList);
        QtCurveEllipseItem* item;
        i.toFront();
        while (i.hasNext())
        {
            item = i.next();
            item->setSelected(false);
        }
    }

    //****************************************************************************/
    qreal QtCurveGrid::fromXValueToPointX (qreal valX)
    {
        return mStartX + mStep + ((valX - mMinX) / mStepX) * mStep;
    }

    //****************************************************************************/
    qreal QtCurveGrid::fromYValueToPointY (qreal valY)
    {
        return mStartY - mStep -((valY - mMinY) / mStepY) * mStep;
    }

    //****************************************************************************/
    qreal QtCurveGrid::fromPointXToXValue (qreal pointX)
    {
        return mMinX + ((pointX - mStartX - mStep) / mStep) * mStepX;
    }

    //****************************************************************************/
    qreal QtCurveGrid::fromPointYToYValue (qreal pointY)
    {
        return mMinY -(((pointY - mStartY + mStep) / mStep) * mStepY);
    }

    //****************************************************************************/
    bool QtCurveGrid::atLeastOnePointSelected (void)
    {
        QVectorIterator<QtCurveEllipseItem*> i(mPointList);
        QtCurveEllipseItem* item;
        i.toFront();
        while (i.hasNext())
        {
            item = i.next();
            if (item->isSelected())
                return true;
        }
        return false;
    }

    //****************************************************************************/
    void QtCurveGrid::removeLineItem (int drawTypes)
    {
        if (mDrawStraightLineUnsortedPath && (drawTypes & STRAIGHTLINE_UNSORTED))
            removeItem(mDrawStraightLineUnsortedPath);

        if (mDrawStraightLineSortedPath && (drawTypes & STRAIGHTLINE_SORTED))
            removeItem(mDrawStraightLineSortedPath);

        if (mDrawCubicUnsortedLinePath && (drawTypes & CUBIC_UNSORTED))
            removeItem(mDrawCubicUnsortedLinePath);

        if (mDrawCubicSortedLinePath && (drawTypes & CUBIC_SORTED))
            removeItem(mDrawCubicSortedLinePath);
    }

}

/****************************************************************************
**
** Copyright (C) 2016
**
** This file is generated by the Magus toolkit
**
** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
** "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
** LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
** A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
** OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
** LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
** DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
** OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
**
****************************************************************************/

// Include
#include <QMessageBox>
#include <QLinearGradient>
#include "tool_gradient.h"

namespace Magus
{
    //****************************************************************************/
    QtGradient::QtGradient(QGraphicsItem* parent) : QGraphicsPathItem(parent)
    {
        //setFlag(QGraphicsItem::ItemIgnoresTransformations);
        mSize.setWidth(408);
        mSize.setHeight(DEFAULT_GRADIENT_HEIGHT);
        mBackground = new QGraphicsPathItem(this);
        mForeground = new QGraphicsPathItem(this);
        drawBackground();
        init();
    }

    //****************************************************************************/
    QtGradient::~QtGradient(void)
    {
    }

    //****************************************************************************/
    void QtGradient::init (void)
    {
        mColorFractionMap.clear();
        mAlphaFractionMap.clear();
        drawGradient();
    }

    //****************************************************************************/
    void QtGradient::addColor (int id, qreal fraction, const QColor& color)
    {
        QtColorFraction cf;
        cf.id = id;
        cf.fraction = fraction;
        cf.color = color;
        mColorFractionMap.insertMulti(cf.fraction, cf);
        drawGradient();
    }

    //****************************************************************************/
    void QtGradient::changeColorFraction (int id, qreal newFraction)
    {
        QMultiMap<qreal, QtColorFraction>::iterator iC;
        QtColorFraction cf;
        for (iC = mColorFractionMap.begin(); iC != mColorFractionMap.end(); ++iC)
        {
            cf = iC.value();
            if (id == cf.id)
            {
                //QMessageBox::information(0, "test", QVariant(id).toString()); // Test
                mColorFractionMap.erase(iC);
                cf.fraction = newFraction;
                mColorFractionMap.insertMulti(cf.fraction, cf);
                drawGradient();
                return;
            }
        }
    }

    //****************************************************************************/
    void QtGradient::changeColor (int id, const QColor& newColor)
    {
        QMultiMap<qreal, QtColorFraction>::iterator iC;
        QtColorFraction cf;
        for (iC = mColorFractionMap.begin(); iC != mColorFractionMap.end(); ++iC)
        {
            cf = iC.value();
            if (id == cf.id)
            {
                mColorFractionMap.erase(iC);
                cf.color = newColor;
                mColorFractionMap.insertMulti(cf.fraction, cf);
                drawGradient();
                return;
            }
        }
    }

    //****************************************************************************/
    qreal QtGradient::getNumColor (void) const
    {
        return mColorFractionMap.count();
    }

    //****************************************************************************/
    void QtGradient::deleteColor (int id)
    {
        QMultiMap<qreal, QtColorFraction>::iterator iC;
        QtColorFraction cf;
        for (iC = mColorFractionMap.begin(); iC != mColorFractionMap.end(); ++iC)
        {
            cf = iC.value();
            if (id == cf.id)
            {
                mColorFractionMap.erase(iC);
                drawGradient();
                return;
            }
        }
    }

    //****************************************************************************/
    void QtGradient::addAlpha (int id, qreal fraction, int alpha)
    {
        QtAlphaFraction af;
        af.id = id;
        af.fraction = fraction;
        af.alpha = alpha;
        mAlphaFractionMap.insertMulti(af.fraction, af);
        drawGradient();
    }

    //****************************************************************************/
    void QtGradient::changeAlphaFraction(int id, qreal newFraction)
    {
        QMultiMap<qreal, QtAlphaFraction>::iterator iA;
        QtAlphaFraction af;
        for (iA = mAlphaFractionMap.begin(); iA != mAlphaFractionMap.end(); ++iA)
        {
            af = iA.value();
            if (id == af.id)
            {
                mAlphaFractionMap.erase(iA);
                af.fraction = newFraction;
                mAlphaFractionMap.insertMulti(af.fraction, af);
                drawGradient();
                return;
            }
        }
    }


    //****************************************************************************/
    void QtGradient::changeAlpha (int id, int newAlpha)
    {
        QMultiMap<qreal, QtAlphaFraction>::iterator iA;
        QtAlphaFraction af;
        for (iA = mAlphaFractionMap.begin(); iA != mAlphaFractionMap.end(); ++iA)
        {
            af = iA.value();
            if (id == af.id)
            {
                mAlphaFractionMap.erase(iA);
                af.alpha = newAlpha;
                mAlphaFractionMap.insertMulti(af.fraction, af);
                drawGradient();
                return;
            }
        }
    }

    //****************************************************************************/
    qreal QtGradient::getNumAlpha (void) const
    {
        return mAlphaFractionMap.count();
    }

    //****************************************************************************/
    void QtGradient::deleteAlpha (int id)
    {
        QMultiMap<qreal, QtAlphaFraction>::iterator iA;
        QtAlphaFraction af;
        for (iA = mAlphaFractionMap.begin(); iA != mAlphaFractionMap.end(); ++iA)
        {
            af = iA.value();
            if (id == af.id)
            {
                mAlphaFractionMap.erase(iA);
                drawGradient();
                return;
            }
        }
    }

    //****************************************************************************/
    void QtGradient::drawBackground (void)
    {
        QBrush brush;
        brush.setStyle(Qt::SolidPattern);
        brush.setColor(QColor("#000000"));
        QPainterPath p;
        qreal step = 8.0f;
        qreal twoStep = 16.0f;
        qreal maxX = mSize.width();
        qreal maxY = mSize.height();

        for (qreal x = 0; x < maxX; x += twoStep)
            p.addRect(x, 0, step, mSize.height());

        for (qreal y = 0; y < maxY; y += twoStep)
        {
            if (y + step > maxY)
                step = maxY - y;
            p.addRect(0, y, mSize.width(), step);
        }

        mBackground->setPath(p);
        mBackground->setBrush(brush);
    }

    //****************************************************************************/
    void QtGradient::drawGradient(void)
    {
        QPainterPath p;
        p.addRect(0, 0, mSize.width(), mSize.height());
        mForeground->setPath(p);

        // Set the color
        QLinearGradient linearGrad(0, 0, mSize.width(), mSize.height());
        QMultiMap<qreal, QtColorFraction>::iterator iC;
        QtColorFraction cf;
        for (iC = mColorFractionMap.begin(); iC != mColorFractionMap.end(); ++iC)
        {
            cf = iC.value();
            int alpha = getInterpolatedAlpha(cf.fraction);
            cf.color.setAlpha(alpha);
            linearGrad.setColorAt(cf.fraction, cf.color);
        }

        QBrush brush(linearGrad);
        mForeground->setBrush(brush);
    }

    //****************************************************************************/
    int QtGradient::getInterpolatedAlpha (qreal colorFraction)
    {
        if (colorFraction < 0.0f)
            colorFraction = 0.0f;
        if (colorFraction > 255.0f)
            colorFraction = 255.0f;
        qreal alphaFraction1 = 0.0f;
        int alphaValue1 = 255.0f;
        qreal alphaFraction2 = 1.0f;
        int alphaValue2 = 255;
        bool end = false;
        QtAlphaFraction af;
        QMultiMap<qreal, QtAlphaFraction>::iterator i = mAlphaFractionMap.begin();
        if (i != mAlphaFractionMap.end())
        {
            alphaFraction2 = i.key();
            af = i.value();
            alphaValue2 = af.alpha;
            ++i;
        }
        while (!end)
        {
            if (colorFraction == alphaFraction2)
            {
                // The colormarker and the alphamarker are on the same position
                return alphaValue2;
            }
            else if (colorFraction > alphaFraction1 && colorFraction < alphaFraction2)
            {
                // The colormarker is between 2 alphamarkers
                return alphaValue1 + ((colorFraction - alphaFraction1) / (alphaFraction2 - alphaFraction1)) * (alphaValue2 - alphaValue1);
            }
            alphaFraction1 = alphaFraction2;
            alphaValue1 = alphaValue2;
            if (i != mAlphaFractionMap.end())
            {
                alphaFraction2 = i.key();
                af = i.value();
                alphaValue2 = af.alpha;
                ++i;
            }
            else
            {
                alphaFraction2 = 1.0f;
                alphaValue2 = 255;
                if (colorFraction > alphaFraction1 && colorFraction < alphaFraction2)
                {
                    // The colormarker is right from the last alphamarker
                    return alphaValue1 + ((colorFraction - alphaFraction1) / (alphaFraction2 - alphaFraction1)) * (alphaValue2 - alphaValue1);
                }
                end = true;
            }
        }

        return 255;
    }

    //****************************************************************************/
    void QtGradient::setSize (QSizeF size)
    {
        mSize = size;
        drawGradient();
        drawBackground();
    }

    //****************************************************************************/
    QMultiMap<qreal, QColor> QtGradient::getColorMap(void)
    {
        QMultiMap<qreal, QColor> map;
        QMultiMap<qreal, QtColorFraction>::iterator iC;
        QtColorFraction cf;
        for (iC = mColorFractionMap.begin(); iC != mColorFractionMap.end(); ++iC)
        {
            cf = iC.value();
            map.insertMulti(cf.fraction, cf.color);
        }
        return map;
    }

    //****************************************************************************/
    QMultiMap<qreal, int> QtGradient::getAlphaMap(void)
    {
        QMultiMap<qreal, int> map;
        QMultiMap<qreal, QtAlphaFraction>::iterator iA;
        QtAlphaFraction af;
        for (iA = mAlphaFractionMap.begin(); iA != mAlphaFractionMap.end(); ++iA)
        {
            af = iA.value();
            map.insertMulti(af.fraction, af.alpha);
        }
        return map;
    }

    //****************************************************************************/
    QMultiMap<qreal, QColor> QtGradient::exportColorAndAlpha(void)
    {
        QMultiMap<qreal, QColor> map;
        QMultiMap<qreal, QtColorFraction>::iterator iC;
        QtColorFraction cf;
        for (iC = mColorFractionMap.begin(); iC != mColorFractionMap.end(); ++iC)
        {
            cf = iC.value();
            int alpha = getInterpolatedAlpha(cf.fraction);
            cf.color.setAlpha(alpha);
            map.insertMulti(cf.fraction, cf.color);
        }

        return map;
    }

    //****************************************************************************/
    void QtGradient::importColorAndAlpha(QMultiMap<qreal, QColor> colorMap)
    {
        QMultiMap<qreal, QColor>::iterator iC;
        qreal fraction;
        QColor color;
        for (iC = colorMap.begin(); iC != colorMap.end(); ++iC)
        {
            fraction = iC.key();
            color = iC.value();
            addColor (0, fraction, color);
            addAlpha (0, fraction, color.alpha());
        }
    }

}
